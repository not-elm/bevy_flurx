<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bevy_flurx</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">bevy_flurx</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bevy_flurx-overview"><a class="header" href="#bevy_flurx-overview">bevy_flurx Overview</a></h1>
<blockquote>
<p><strong>Note:</strong>
This document is generated by AI. If you find any mistakes or unnatural parts, please report them in the issue.</p>
</blockquote>
<p>bevy_flurx is a library that provides functionality similar to coroutines for the Bevy game engine, allowing you to write sequential processing for delays, user input, animations, and more.</p>
<h2 id="what-is-bevy_flurx"><a class="header" href="#what-is-bevy_flurx">What is bevy_flurx?</a></h2>
<p>bevy_flurx allows you to write asynchronous code in a sequential manner, making it easier to implement complex behaviors that involve waiting for events, delays, or other conditions. The library is designed to be used incrementally, meaning there's no need to rewrite existing applications to incorporate it.</p>
<p>The main component of bevy_flurx is the <code>Reactor</code>, which schedules and executes tasks. Each task can use various actions to perform operations or wait for conditions.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Sequential Processing</strong>: Write code that looks sequential but executes asynchronously</li>
<li><strong>Incremental Adoption</strong>: Use alongside existing Bevy systems without rewriting your application</li>
<li><strong>Rich Action Library</strong>: Various actions for different use cases:
<ul>
<li><code>once</code>: Actions that run only once</li>
<li><code>wait</code>: Actions that continue to execute every frame according to specified conditions</li>
<li><code>delay</code>: Actions that perform delay processing</li>
<li>Action chaining with <code>then</code>, <code>pipe</code>, and <code>through</code></li>
</ul>
</li>
</ul>
<h2 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

fn main() {
    App::new()
        .insert_resource(Count(0))
        .add_plugins((
            DefaultPlugins,
            FlurxPlugin,
        ))
        .add_systems(Startup, spawn_reactor)
        .run();
}

#[derive(Resource)]
struct Count(usize);

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Run a system once
        let current_count: usize = task.will(Update, once::run(|mut count: ResMut&lt;Count&gt;| {
            count.0 += 1;
            count.0
        })).await;
        
        // Wait until a condition is met
        task.will(Update, wait::until(|mut count: ResMut&lt;Count&gt;| {
            count.0 += 1;
            count.0 == 4
        })).await;
        
        // Delay for a specific time
        task.will(Update, delay::time().with(Duration::from_secs(1))).await;
        
        // Chain actions together
        let message = task.will(Update, {
            delay::frames().with(30)
                .then(once::run(|count: Res&lt;Count&gt;| {
                    count.0
                }))
                .pipe(once::run(|In(count): In&lt;usize&gt;| {
                    format!("count is {count}")
                }))
        }).await;
        
        info!("Done!");
    }));
}</code></pre></pre>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>bevy_flurx provides several feature flags to enable additional functionality:</p>
<div class="table-wrapper"><table><thead><tr><th>Flag Name</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td>audio</td><td>Audio actions</td><td>false</td></tr>
<tr><td>record</td><td>Undo/redo actions and events</td><td>false</td></tr>
<tr><td>side-effect</td><td>Thread/async side effects</td><td>false</td></tr>
<tr><td>state</td><td>State actions</td><td>false</td></tr>
<tr><td>tokio</td><td>Use tokio's runtime directly in the reactor</td><td>false</td></tr>
<tr><td>std</td><td>Enable features that depend on the standard library</td><td>false</td></tr>
</tbody></table>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Check out the <a href="./actions/index.html">Actions</a> section to learn more about the different types of actions available in bevy_flurx.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<p>Actions are the core building blocks of bevy_flurx. They define how tasks behave and interact with the Bevy ECS. This section provides an overview of the different types of actions available in bevy_flurx.</p>
<h2 id="action-types"><a class="header" href="#action-types">Action Types</a></h2>
<p>bevy_flurx provides several types of actions for different use cases:</p>
<h3 id="once"><a class="header" href="#once">once</a></h3>
<p>The <code>once</code> module defines actions that run only once. These are useful for performing one-time operations, such as initializing resources, spawning entities, or sending events.</p>
<p><a href="actions/./once/index.html">Learn more about once actions</a></p>
<h3 id="wait"><a class="header" href="#wait">wait</a></h3>
<p>The <code>wait</code> module defines actions that continue to execute every frame according to specified conditions. These are useful for waiting for user input, events, or other conditions to be met.</p>
<p><a href="actions/./wait/index.html">Learn more about wait actions</a></p>
<h3 id="delay"><a class="header" href="#delay">delay</a></h3>
<p>The <code>delay</code> module defines actions that perform delay processing. These are useful for waiting for a specific amount of time or a specific number of frames.</p>
<p><a href="actions/./delay.html">Learn more about delay actions</a></p>
<h3 id="omit"><a class="header" href="#omit">omit</a></h3>
<p>The <code>omit</code> module provides mechanisms to omit input and/or output types from an action. This is particularly useful for defining groups of actions by simplifying their type signatures.</p>
<p><a href="actions/./omit.html">Learn more about omit actions</a></p>
<h3 id="sequence"><a class="header" href="#sequence">sequence</a></h3>
<p>The <code>sequence</code> module provides mechanisms for sequentially combining actions. This is particularly useful for creating complex action flows by chaining multiple actions together.</p>
<p><a href="actions/./sequence.html">Learn more about sequence actions</a></p>
<h3 id="pipe"><a class="header" href="#pipe">pipe</a></h3>
<p>The <code>pipe</code> module provides a mechanism to pipe actions together, where the output of one action is used as the input for another action. This is particularly useful for creating data processing pipelines.</p>
<p><a href="actions/./pipe.html">Learn more about pipe actions</a></p>
<h3 id="through"><a class="header" href="#through">through</a></h3>
<p>The <code>through</code> module provides a mechanism to execute an action while preserving the output of the previous action. This is particularly useful for inserting actions like delays into a pipeline without affecting the data flow.</p>
<p><a href="actions/./through.html">Learn more about through actions</a></p>
<h3 id="map"><a class="header" href="#map">map</a></h3>
<p>The <code>map</code> module provides mechanisms to transform the output of an action using a mapping function. This is particularly useful for data transformation and type conversion between actions.</p>
<p><a href="actions/./map.html">Learn more about map actions</a></p>
<h3 id="inspect"><a class="header" href="#inspect">inspect</a></h3>
<p>The <code>inspect</code> module provides mechanisms to clone and inspect input values via auxiliary actions without disrupting their primary flow. This is particularly useful for debugging, logging, or performing side-effects on input values.</p>
<p><a href="actions/./inspect.html">Learn more about inspect actions</a></p>
<h3 id="remake"><a class="header" href="#remake">remake</a></h3>
<p>The <code>remake</code> module provides a mechanism to create a new action based on an existing action's <code>Runner</code> and <code>Output</code>. This is particularly useful for transforming actions while preserving their input type but changing their output type.</p>
<p><a href="actions/./remake.html">Learn more about remake actions</a></p>
<h2 id="action-chaining"><a class="header" href="#action-chaining">Action Chaining</a></h2>
<p>bevy_flurx provides several ways to chain actions together:</p>
<h3 id="then"><a class="header" href="#then">then</a></h3>
<p>The <code>then</code> method allows you to execute one action after another. The output of the first action is discarded, and the output of the second action is returned.</p>
<h3 id="pipe-1"><a class="header" href="#pipe-1">pipe</a></h3>
<p>The <code>pipe</code> method allows you to pass the output of one action as the input to another action.</p>
<h3 id="through-1"><a class="header" href="#through-1">through</a></h3>
<p>The <code>through</code> method allows you to execute an action while preserving the output of the previous action.</p>
<h2 id="feature-gated-actions"><a class="header" href="#feature-gated-actions">Feature-Gated Actions</a></h2>
<p>bevy_flurx provides additional actions through feature flags:</p>
<h3 id="audio"><a class="header" href="#audio">audio</a></h3>
<p>The <code>audio</code> feature provides actions for audio playback and waiting.</p>
<h3 id="record"><a class="header" href="#record">record</a></h3>
<p>The <code>record</code> feature provides actions for undo/redo functionality.</p>
<h3 id="side-effect"><a class="header" href="#side-effect">side-effect</a></h3>
<p>The <code>side-effect</code> feature provides actions for handling side effects like asynchronous runtime or threads.</p>
<h3 id="state"><a class="header" href="#state">state</a></h3>
<p>The <code>state</code> feature provides actions for state management.</p>
<h3 id="tokio"><a class="header" href="#tokio">tokio</a></h3>
<p>The <code>tokio</code> feature allows you to use tokio's runtime directly in the reactor.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Explore the specific action types to learn more about their capabilities and how to use them:</p>
<ul>
<li><a href="actions/./once.html">once</a></li>
<li><a href="actions/./wait.html">wait</a></li>
<li><a href="actions/./delay.html">delay</a></li>
<li><a href="actions/./omit.html">omit</a></li>
<li><a href="actions/./sequence.html">sequence</a></li>
<li><a href="actions/./pipe.html">pipe</a></li>
<li><a href="actions/./through.html">through</a></li>
<li><a href="actions/./map.html">map</a></li>
<li><a href="actions/./inspect.html">inspect</a></li>
<li><a href="actions/./remake.html">remake</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="once-actions"><a class="header" href="#once-actions">Once Actions</a></h1>
<p>Once actions are actions that run a system exactly once and then complete.
They are useful for one-time operations like sending events, modifying resources, or performing state transitions.</p>
<h2 id="available-once-actions"><a class="header" href="#available-once-actions">Available Once Actions</a></h2>
<ul>
<li><a href="actions/once/run.html">run</a> - Run a system once</li>
<li><a href="actions/once/event.html">event</a> - Send an event once</li>
<li><a href="actions/once/res.html">res</a> - Modify a resource once</li>
<li><a href="actions/once/non_send.html">non_send</a> - Modify a non-send resource once</li>
<li><a href="actions/once/switch.html">switch</a> - Switch between actions based on a condition</li>
<li><a href="actions/once/state.html">state</a> - Transition to a new state once</li>
<li><a href="actions/once/audio.html">audio</a> - Play audio once</li>
</ul>
<p>Each action is designed to be used with the <code>Reactor::schedule</code> or <code>task.will</code> methods to schedule a one-time operation.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Run a system once during the Update schedule
Reactor::schedule(|task| async move {
    task.will(Update, once::run(|world: &amp;mut World| {
        // Do something once
    })).await;
});
<span class="boring">}</span></code></pre></pre>
<p>The once actions are part of the core functionality of bevy_flurx, providing simple building blocks for more complex action sequences.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oncerun"><a class="header" href="#oncerun">once::run</a></h1>
<p>The <code>once::run</code> action executes a system exactly once and then completes. This is the most basic and versatile once action, allowing you to run any Bevy system as a one-time operation.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    task.will(Update, once::run(|world: &amp;mut World| {
        // Your one-time logic here
    })).await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li><code>system</code>: Any valid Bevy system that can be converted using <code>IntoSystem</code></li>
</ul>
<h2 id="return-value"><a class="header" href="#return-value">Return Value</a></h2>
<p>The action returns the value returned by the system.</p>
<h2 id="example-sending-an-app-exit-event"><a class="header" href="#example-sending-an-app-exit-event">Example: Sending an App Exit Event</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::app::AppExit;
use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    task.will(Update, once::run(|mut ew: EventWriter&lt;AppExit&gt;| {
        ew.write(AppExit::Success);
    })).await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="example-modifying-a-resource"><a class="header" href="#example-modifying-a-resource">Example: Modifying a Resource</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Resource, Default)]
struct Score(u32);

Reactor::schedule(|task| async move {
    task.will(Update, once::run(|mut score: ResMut&lt;Score&gt;| {
        score.0 += 10;
    })).await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h2>
<p>Use <code>once::run</code> when you need to:</p>
<ul>
<li>Execute arbitrary logic once</li>
<li>Access multiple system parameters in a single action</li>
<li>Return a custom value from your action</li>
</ul>
<p>For more specific use cases, consider the specialized once actions like <code>once::event</code> or <code>once::res</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="onceevent"><a class="header" href="#onceevent">once::event</a></h1>
<p>The <code>once::event</code> module provides actions for sending Bevy events exactly once. These actions are specialized versions of <code>once::run</code> that focus specifically on event sending operations.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="send"><a class="header" href="#send">send</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::event::send&lt;E&gt;() -&gt; ActionSeed&lt;E, ()&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that sends a specified event once. The event must be provided using the <code>.with()</code> method.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::app::AppExit;
use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    task.will(Update, once::event::send().with(AppExit::Success)).await;
});
<span class="boring">}</span></code></pre></pre>
<h3 id="send_default"><a class="header" href="#send_default">send_default</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::event::send_default&lt;E&gt;() -&gt; ActionSeed
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that sends a default-constructed event once. The event type must implement the <code>Default</code> trait.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::app::AppExit;
use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    task.will(Update, once::event::send_default::&lt;AppExit&gt;()).await;
});
<span class="boring">}</span></code></pre></pre>
<h3 id="app_exit_success"><a class="header" href="#app_exit_success">app_exit_success</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::event::app_exit_success() -&gt; Action&lt;AppExit, ()&gt;
<span class="boring">}</span></code></pre></pre>
<p>A convenience function that creates an action to send the <code>AppExit::Success</code> event once, which will exit the application successfully.</p>
<h4 id="example-2"><a class="header" href="#example-2">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    task.will(Update, once::event::app_exit_success()).await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-1"><a class="header" href="#when-to-use-1">When to Use</a></h2>
<p>Use <code>once::event</code> actions when you need to:</p>
<ul>
<li>Send a specific event exactly once</li>
<li>Send a default-constructed event exactly once</li>
<li>Exit the application with a success status</li>
</ul>
<p>For more complex event handling or when you need to access other system parameters, consider using the more general <code>once::run</code> action.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="onceres"><a class="header" href="#onceres">once::res</a></h1>
<p>The <code>once::res</code> module provides actions for managing Bevy resources exactly once. These actions are specialized versions of <code>once::run</code> that focus specifically on resource operations.</p>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<h3 id="init"><a class="header" href="#init">init</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::res::init&lt;R&gt;() -&gt; ActionSeed
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that initializes a resource using its <code>Default</code> implementation. The resource will only be initialized if it doesn't already exist.</p>
<h4 id="example-3"><a class="header" href="#example-3">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Resource, Default)]
struct GameScore(u32);

Reactor::schedule(|task| async move {
    task.will(Update, once::res::init::&lt;GameScore&gt;()).await;
});
<span class="boring">}</span></code></pre></pre>
<h3 id="insert"><a class="header" href="#insert">insert</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::res::insert&lt;R&gt;() -&gt; ActionSeed&lt;R&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that inserts a provided resource. If the resource already exists, it will be replaced.</p>
<h4 id="example-4"><a class="header" href="#example-4">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Resource)]
struct GameScore(u32);

Reactor::schedule(|task| async move {
    task.will(Update, once::res::insert().with(GameScore(100))).await;
});
<span class="boring">}</span></code></pre></pre>
<h3 id="remove"><a class="header" href="#remove">remove</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::res::remove&lt;R&gt;() -&gt; ActionSeed
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that removes a resource if it exists.</p>
<h4 id="example-5"><a class="header" href="#example-5">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Resource)]
struct TemporaryResource;

Reactor::schedule(|task| async move {
    task.will(Update, once::res::remove::&lt;TemporaryResource&gt;()).await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-2"><a class="header" href="#when-to-use-2">When to Use</a></h2>
<p>Use <code>once::res</code> actions when you need to:</p>
<ul>
<li>Initialize a resource with its default value</li>
<li>Insert or replace a resource with a specific value</li>
<li>Remove a resource that's no longer needed</li>
</ul>
<p>For more complex resource operations or when you need to access other system parameters, consider using the more general <code>once::run</code> action with <code>ResMut</code> or <code>Res</code> parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oncenon_send"><a class="header" href="#oncenon_send">once::non_send</a></h1>
<p>The <code>once::non_send</code> module provides actions for managing Bevy non-send resources exactly once. Non-send resources are resources that are not thread-safe and can only be accessed from the main thread.</p>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<h3 id="init-1"><a class="header" href="#init-1">init</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::non_send::init&lt;R&gt;() -&gt; ActionSeed
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that initializes a non-send resource using its <code>Default</code> implementation. The resource will only be initialized if it doesn't already exist.</p>
<h4 id="example-6"><a class="header" href="#example-6">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Default)]
struct WindowHandle(/* some non-Send type */);

Reactor::schedule(|task| async move {
    task.will(Update, once::non_send::init::&lt;WindowHandle&gt;()).await;
});
<span class="boring">}</span></code></pre></pre>
<h3 id="insert-1"><a class="header" href="#insert-1">insert</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::non_send::insert&lt;R&gt;() -&gt; ActionSeed&lt;R&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that inserts a provided non-send resource. If the resource already exists, it will be replaced.</p>
<h4 id="example-7"><a class="header" href="#example-7">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct WindowHandle(/* some non-Send type */);

Reactor::schedule(|task| async move {
    task.will(Update, once::non_send::insert().with(WindowHandle(/* ... */)))
        .await;
});
<span class="boring">}</span></code></pre></pre>
<h3 id="remove-1"><a class="header" href="#remove-1">remove</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::non_send::remove&lt;R&gt;() -&gt; ActionSeed
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that removes a non-send resource if it exists.</p>
<h4 id="example-8"><a class="header" href="#example-8">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct WindowHandle(/* some non-Send type */);

Reactor::schedule(|task| async move {
    task.will(Update, once::non_send::remove::&lt;WindowHandle&gt;()).await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-3"><a class="header" href="#when-to-use-3">When to Use</a></h2>
<p>Use <code>once::non_send</code> actions when you need to:</p>
<ul>
<li>Initialize a non-send resource with its default value</li>
<li>Insert or replace a non-send resource with a specific value</li>
<li>Remove a non-send resource that's no longer needed</li>
</ul>
<p>Non-send resources are typically used for resources that contain types that cannot be sent between threads, such as:</p>
<ul>
<li>Raw pointers</li>
<li>File handles</li>
<li>Window handles</li>
<li>Other platform-specific resources</li>
</ul>
<p>For more complex non-send resource operations or when you need to access other system parameters, consider using the more general <code>once::run</code> action with <code>NonSendMut</code> or <code>NonSend</code> parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="onceswitch"><a class="header" href="#onceswitch">once::switch</a></h1>
<p>The <code>once::switch</code> module provides actions for controlling Bevy switches exactly once. Switches are a mechanism in bevy_flurx that represent two states (on and off) and can be used to coordinate between Reactors and regular Bevy systems.</p>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<h3 id="on"><a class="header" href="#on">on</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::switch::on&lt;M&gt;() -&gt; ActionSeed
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that turns a switch on. If the switch doesn't exist, it will be created.</p>
<h4 id="example-9"><a class="header" href="#example-9">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Define a marker type for our switch
struct PlayerAnimation;

Reactor::schedule(|task| async move {
    // Turn on the PlayerAnimation switch
    task.will(Update, once::switch::on::&lt;PlayerAnimation&gt;()).await;
});
<span class="boring">}</span></code></pre></pre>
<h3 id="off"><a class="header" href="#off">off</a></h3>
<pre><code>once::switch::off&lt;M&gt;() -&gt; ActionSeed
</code></pre>
<p>Creates an action that turns a switch off. If the switch doesn't exist, it will be created in the off state.</p>
<h4 id="example-10"><a class="header" href="#example-10">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Define a marker type for our switch
struct PlayerAnimation;

Reactor::schedule(|task| async move {
    // Turn off the PlayerAnimation switch
    task.will(Update, once::switch::off::&lt;PlayerAnimation&gt;()).await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="using-switches-with-systems"><a class="header" href="#using-switches-with-systems">Using Switches with Systems</a></h2>
<p>Switches are designed to be used with Bevy's <code>run_if</code> condition system to control when systems run:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct HeavyTask;

fn main() {
    App::new()
        // This system only runs when the HeavyTask switch is on
        .add_systems(Update, (|mut switch: ResMut&lt;Switch&lt;HeavyTask&gt;&gt;| {
            // Do heavy work...

            // Turn off the switch when done
            switch.off();
        }).run_if(switch_is_on::&lt;HeavyTask&gt;))

        // Spawn a reactor that turns the switch on and waits for it to be turned off
        .add_systems(Startup, |mut commands: Commands| {
            commands.spawn(Reactor::schedule(|task| async move {
                task.will(Update, once::switch::on::&lt;HeavyTask&gt;()).await;
                task.will(Update, wait::switch::off::&lt;HeavyTask&gt;()).await;
                // Continue after the heavy task is complete...
            }));
        });
}</code></pre></pre>
<h2 id="available-conditions"><a class="header" href="#available-conditions">Available Conditions</a></h2>
<p>The following conditions can be used with <code>run_if</code>:</p>
<ul>
<li><code>switch_is_on&lt;M&gt;()</code> - Returns true if the switch is on</li>
<li><code>switch_is_off&lt;M&gt;()</code> - Returns true if the switch is off</li>
<li><code>switch_just_turned_on&lt;M&gt;()</code> - Returns true only the first time the switch is detected as on</li>
<li><code>switch_just_turned_off&lt;M&gt;()</code> - Returns true only the first time the switch is detected as off</li>
</ul>
<h2 id="when-to-use-4"><a class="header" href="#when-to-use-4">When to Use</a></h2>
<p>Use <code>once::switch</code> actions when you need to:</p>
<ul>
<li>Coordinate between Reactors and regular Bevy systems</li>
<li>Control when certain systems should run</li>
<li>Signal the completion of asynchronous tasks</li>
<li>Create state machines with clear on/off states</li>
</ul>
<p>Switches are particularly useful for tasks that need to be performed on the main thread but need to be coordinated with asynchronous Reactor tasks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oncestate"><a class="header" href="#oncestate">once::state</a></h1>
<p>The <code>once::state</code> module provides actions for managing Bevy state transitions exactly once. This module is designed to work with Bevy's <a href="https://docs.rs/bevy/latest/bevy/ecs/schedule/struct.States.html">States</a> system.</p>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<h3 id="set"><a class="header" href="#set">set</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::state::set&lt;S&gt;() -&gt; ActionSeed&lt;S&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that sets the next state for a Bevy state machine. The state value must be provided using the <code>.with()</code> method.</p>
<h4 id="example-11"><a class="header" href="#example-11">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(States, Copy, Clone, Hash, Eq, PartialEq, Default, Debug)]
enum GameState {
    #[default]
    MainMenu,
    Playing,
    Paused,
    GameOver,
}

Reactor::schedule(|task| async move {
    // Wait for some condition...
    
    // Transition to the Playing state
    task.will(Update, once::state::set().with(GameState::Playing)).await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="state-machines-in-bevy"><a class="header" href="#state-machines-in-bevy">State Machines in Bevy</a></h2>
<p>Bevy's state system allows you to organize your game into distinct states, with systems that run only during specific states. The <code>once::state::set()</code> action provides a way to trigger state transitions from within a Reactor.</p>
<h2 id="when-to-use-5"><a class="header" href="#when-to-use-5">When to Use</a></h2>
<p>Use <code>once::state</code> actions when you need to:</p>
<ul>
<li>Trigger state transitions from within a Reactor</li>
<li>Create game flow sequences that involve state changes</li>
<li>Coordinate asynchronous operations with state-based systems</li>
</ul>
<p>For more complex state management or when you need to access other system parameters, consider using the more general <code>once::run</code> action with <code>ResMut&lt;NextState&lt;S&gt;&gt;</code> parameter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="onceaudio"><a class="header" href="#onceaudio">once::audio</a></h1>
<p>The <code>once::audio</code> module provides actions for playing audio in Bevy exactly once. This module is designed to work with Bevy's audio system.</p>
<h2 id="functions-5"><a class="header" href="#functions-5">Functions</a></h2>
<h3 id="play"><a class="header" href="#play">play</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>once::audio::play&lt;Path&gt;() -&gt; ActionSeed&lt;Path, Entity&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that plays an audio file once. The path to the audio file must be provided using the <code>.with()</code> method. The action returns the Entity that the AudioBundle is attached to.</p>
<h4 id="example-12"><a class="header" href="#example-12">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Play a sound effect once
    let entity = task.will(Update, once::audio::play().with("sounds/explosion.ogg")).await;

    // You can use the returned entity to control the audio later if needed
    println!("Audio playing on entity: {:?}", entity);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="audio-paths"><a class="header" href="#audio-paths">Audio Paths</a></h2>
<p>The path provided to <code>once::audio::play()</code> is loaded using Bevy's AssetServer, so it should be relative to your project's asset directory. The following audio formats are supported by default in Bevy:</p>
<ul>
<li>.ogg (Vorbis)</li>
<li>.mp3</li>
<li>.wav</li>
<li>.flac</li>
</ul>
<h2 id="when-to-use-6"><a class="header" href="#when-to-use-6">When to Use</a></h2>
<p>Use <code>once::audio</code> actions when you need to:</p>
<ul>
<li>Play sound effects in response to game events</li>
<li>Start background music</li>
<li>Create audio sequences as part of game flow</li>
</ul>
<p>For more complex audio control or when you need to access other system parameters, consider using the more general <code>once::run</code> action with the appropriate audio components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wait-actions"><a class="header" href="#wait-actions">Wait Actions</a></h1>
<p>Wait actions are tasks that continue to execute every frame according to specified conditions. They are useful for creating reactive behaviors that respond to events, input, state changes, or other conditions.</p>
<h2 id="available-wait-actions"><a class="header" href="#available-wait-actions">Available Wait Actions</a></h2>
<ul>
<li><a href="actions/wait/until.html">until</a> - Wait until a condition is true</li>
<li><a href="actions/wait/output.html">output</a> - Wait until a system returns Some value</li>
<li><a href="actions/wait/event.html">event</a> - Wait for events</li>
<li><a href="actions/wait/switch.html">switch</a> - Wait for switch state changes</li>
<li><a href="actions/wait/state.html">state</a> - Wait for state transitions</li>
<li><a href="actions/wait/audio.html">audio</a> - Wait for audio playback to finish</li>
<li><a href="actions/wait/input.html">input</a> - Wait for input events</li>
<li><a href="actions/wait/all.html">all</a> - Wait for all actions to complete</li>
<li><a href="actions/wait/any.html">any</a> - Wait for any action to complete</li>
<li><a href="actions/wait/both.html">both</a> - Wait for two actions to complete</li>
<li><a href="actions/wait/either.html">either</a> - Wait for either of two actions to complete</li>
</ul>
<p>Each action is designed to be used with the <code>Reactor::schedule</code> or <code>task.will</code> methods to create tasks that wait for specific conditions before continuing.</p>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<pre><code>use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Wait until a condition is met
Reactor::schedule(|task| async move {
    task.will(Update, wait::until(|mut count: Local&lt;usize&gt;| {
        *count += 1;
        *count == 4  // Wait until this condition is true
    })).await;

    // This code runs after the condition is met
    println!("Condition met!");
});
</code></pre>
<p>The wait actions are part of the core functionality of bevy_flurx, providing powerful tools for creating reactive and event-driven behaviors in your Bevy applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waituntil"><a class="header" href="#waituntil">wait::until</a></h1>
<p>The <code>wait::until</code> action continues to execute a system every frame until it returns <code>true</code>. This is one of the most basic and versatile wait actions, allowing you to wait for any condition to be met.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    task.will(Update, wait::until(|world: &amp;mut World| {
        // Your condition here
        true // Replace with your actual condition
    })).await;
});
<span class="boring">}</span></code></pre></pre>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<ul>
<li><code>system</code>: Any valid Bevy system that returns a boolean value</li>
</ul>
<h2 id="return-value-1"><a class="header" href="#return-value-1">Return Value</a></h2>
<p>The action returns <code>()</code> (unit) when the condition becomes true.</p>
<h2 id="example-waiting-for-a-counter"><a class="header" href="#example-waiting-for-a-counter">Example: Waiting for a Counter</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    task.will(Update, wait::until(|mut count: Local&lt;usize&gt;| {
        *count += 1;
        *count == 4  // Wait until the counter reaches 4
    })).await;
    
    // This code runs after the counter reaches 4
    println!("Counter reached 4!");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="example-waiting-for-a-resource-value"><a class="header" href="#example-waiting-for-a-resource-value">Example: Waiting for a Resource Value</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Resource, Default)]
struct Score(u32);

Reactor::schedule(|task| async move {
    task.will(Update, wait::until(|score: Res&lt;Score&gt;| {
        score.0 &gt;= 100  // Wait until the score is at least 100
    })).await;
    
    // This code runs after the score reaches 100
    println!("Score reached 100!");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-7"><a class="header" href="#when-to-use-7">When to Use</a></h2>
<p>Use <code>wait::until</code> when you need to:</p>
<ul>
<li>Wait for a specific condition to be met</li>
<li>Poll a value until it reaches a threshold</li>
<li>Create a delay based on a custom condition</li>
<li>Implement custom waiting logic that isn't covered by other wait actions</li>
</ul>
<p>For more specific waiting scenarios, consider using the specialized wait actions like <code>wait::event</code> or <code>wait::input</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waitoutput"><a class="header" href="#waitoutput">wait::output</a></h1>
<p>The <code>wait::output</code> action continues to execute a system every frame until it returns <code>Option::Some</code>. The contents of <code>Some</code> will be the return value of the task. This action provides more flexibility than <code>wait::until</code> by allowing you to return a value when the waiting condition is met.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    let result = task.will(Update, wait::output(|world: &amp;mut World| {
        // Your logic here
        Some("Result value") // Return Some when condition is met
    })).await;
    
    println!("Got result: {}", result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<ul>
<li><code>system</code>: Any valid Bevy system that returns an <code>Option&lt;T&gt;</code></li>
</ul>
<h2 id="return-value-2"><a class="header" href="#return-value-2">Return Value</a></h2>
<p>The action returns the value inside the <code>Some</code> variant when the system returns <code>Some</code>.</p>
<h2 id="example-waiting-for-a-counter-with-result"><a class="header" href="#example-waiting-for-a-counter-with-result">Example: Waiting for a Counter with Result</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    let count = task.will(Update, wait::output(|mut count: Local&lt;usize&gt;| {
        *count += 1;
        if *count == 4 {
            Some(*count)  // Return the count when it reaches 4
        } else {
            None
        }
    })).await;
    
    // This code runs after the counter reaches 4
    println!("Counter reached: {}", count);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="example-finding-an-entity"><a class="header" href="#example-finding-an-entity">Example: Finding an Entity</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Component)]
struct Target;

Reactor::schedule(|task| async move {
    let entity = task.will(Update, wait::output(|query: Query&lt;Entity, With&lt;Target&gt;&gt;| {
        query.iter().next().map(|e| e)  // Return the first entity with Target component
    })).await;
    
    // This code runs after a Target entity is found
    println!("Found target entity: {:?}", entity);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-8"><a class="header" href="#when-to-use-8">When to Use</a></h2>
<p>Use <code>wait::output</code> when you need to:</p>
<ul>
<li>Wait for a condition and get a value when the condition is met</li>
<li>Find an entity or resource that meets certain criteria</li>
<li>Collect data that becomes available at an unpredictable time</li>
<li>Implement custom waiting logic that needs to return a value</li>
</ul>
<p>For simpler cases where you just need to wait for a condition without returning a value, consider using <code>wait::until</code> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waitevent"><a class="header" href="#waitevent">wait::event</a></h1>
<p>The <code>wait::event</code> module provides actions for waiting to receive Bevy events. These actions are useful for creating tasks that respond to events in your game or application.</p>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<h3 id="comes"><a class="header" href="#comes">comes</a></h3>
<pre><code>wait::event::comes&lt;E&gt;() -&gt; ActionSeed
</code></pre>
<p>Creates an action that waits until an event of type <code>E</code> is received. The action completes when the event is received but does not return the event itself.</p>
<h4 id="example-13"><a class="header" href="#example-13">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::app::AppExit;
use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait for an AppExit event
    task.will(Update, wait::event::comes::&lt;AppExit&gt;()).await;
    
    // This code runs after an AppExit event is received
    println!("App is exiting!");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="comes_and"><a class="header" href="#comes_and">comes_and</a></h3>
<pre><code>wait::event::comes_and&lt;E&gt;(predicate: impl Fn(&amp;E) -&gt; bool + Send + Sync + 'static) -&gt; ActionSeed
</code></pre>
<p>Creates an action that waits until an event of type <code>E</code> is received and the event matches the given predicate. The action completes when a matching event is received but does not return the event itself.</p>
<h4 id="example-14"><a class="header" href="#example-14">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::app::AppExit;
use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait for a successful AppExit event
    task.will(Update, wait::event::comes_and::&lt;AppExit&gt;(|e| {
        e.is_success()
    })).await;
    
    // This code runs after a successful AppExit event is received
    println!("App is exiting successfully!");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="read"><a class="header" href="#read">read</a></h3>
<pre><code>wait::event::read&lt;E&gt;() -&gt; ActionSeed&lt;(), E&gt;
</code></pre>
<p>Creates an action that waits until an event of type <code>E</code> is received and returns a clone of the event. This is similar to <code>comes</code>, but it returns the event itself.</p>
<h4 id="example-15"><a class="header" href="#example-15">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::app::AppExit;
use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait for an AppExit event and get the event
    let exit_event = task.will(Update, wait::event::read::&lt;AppExit&gt;()).await;
    
    // This code runs after an AppExit event is received
    println!("App is exiting with status: {:?}", exit_event);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="read_and"><a class="header" href="#read_and">read_and</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait::event::read_and&lt;E&gt;(predicate: impl Fn(&amp;E) -&gt; bool + Send + Sync + 'static) -&gt; ActionSeed&lt;(), E&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that waits until an event of type <code>E</code> is received, the event matches the given predicate, and returns a clone of the event. This is similar to <code>comes_and</code>, but it returns the event itself.</p>
<h4 id="example-16"><a class="header" href="#example-16">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::app::AppExit;
use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait for a successful AppExit event and get the event
    let exit_event = task.will(Update, wait::event::read_and::&lt;AppExit&gt;(|e| {
        e.is_success()
    })).await;
    
    // This code runs after a successful AppExit event is received
    println!("App is exiting successfully with event: {:?}", exit_event);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-9"><a class="header" href="#when-to-use-9">When to Use</a></h2>
<p>Use <code>wait::event</code> actions when you need to:</p>
<ul>
<li>Wait for specific events to occur before continuing execution</li>
<li>React to events in an asynchronous manner</li>
<li>Filter events based on their content using predicates</li>
<li>Retrieve event data for further processing</li>
</ul>
<p>For more complex event handling scenarios, consider combining <code>wait::event</code> with other wait actions like <code>wait::either</code> or <code>wait::any</code> to wait for multiple different event types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waitswitch"><a class="header" href="#waitswitch">wait::switch</a></h1>
<p>The <code>wait::switch</code> module provides actions for waiting for <a href="actions/wait/../../actions/switch.html"><code>Switch</code></a> state changes. These actions are useful for coordinating between different parts of your application, allowing tasks to wait for specific switch state changes before continuing execution.</p>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<h3 id="on-1"><a class="header" href="#on-1">on</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait::switch::on&lt;M&gt;() -&gt; ActionSeed
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that waits until a switch of type <code>M</code> is turned on. The action completes when the switch is detected as on.</p>
<h4 id="example-17"><a class="header" href="#example-17">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Define a marker type for our switch
struct Animation;

Reactor::schedule(|task| async move {
    // Wait until the Animation switch is turned on
    task.will(Update, wait::switch::on::&lt;Animation&gt;()).await;
    
    // This code runs after the Animation switch is turned on
    println!("Animation switch is now on!");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="off-1"><a class="header" href="#off-1">off</a></h3>
<pre><code>wait::switch::off&lt;M&gt;() -&gt; ActionSeed
</code></pre>
<p>Creates an action that waits until a switch of type <code>M</code> is turned off. The action completes when the switch is detected as off.</p>
<h4 id="example-18"><a class="header" href="#example-18">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Define a marker type for our switch
struct Animation;

Reactor::schedule(|task| async move {
    // First turn on the Animation switch
    task.will(Update, once::switch::on::&lt;Animation&gt;()).await;
    
    // Then wait until the Animation switch is turned off
    task.will(Update, wait::switch::off::&lt;Animation&gt;()).await;
    
    // This code runs after the Animation switch is turned off
    println!("Animation switch is now off!");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-10"><a class="header" href="#when-to-use-10">When to Use</a></h2>
<p>Use <code>wait::switch</code> actions when you need to:</p>
<ul>
<li>Coordinate between different systems in your application</li>
<li>Wait for a specific state change before continuing execution</li>
<li>Create state machines with clear on/off states</li>
<li>Implement gameplay sequences that depend on switch states</li>
</ul>
<p>Switches are particularly useful for tasks that need to be performed on the main thread but need to be coordinated with asynchronous Reactor tasks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waitstate"><a class="header" href="#waitstate">wait::state</a></h1>
<p>The <code>wait::state</code> module provides actions for waiting for Bevy state transitions. These actions are useful for coordinating tasks with Bevy's state system, allowing tasks to wait for specific state changes before continuing execution.</p>
<h2 id="functions-8"><a class="header" href="#functions-8">Functions</a></h2>
<h3 id="becomes"><a class="header" href="#becomes">becomes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait::state::becomes&lt;S&gt;() -&gt; ActionSeed&lt;S&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that waits until the state becomes the specified value. The action completes when the state matches the expected value.</p>
<h4 id="example-19"><a class="header" href="#example-19">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(States, Eq, PartialEq, Copy, Clone, Hash, Default, Debug)]
enum GameState {
    #[default]
    MainMenu,
    Playing,
    Paused,
    GameOver,
}

Reactor::schedule(|task| async move {
    // Wait until the game state becomes Playing
    task.will(Update, wait::state::becomes().with(GameState::Playing)).await;
    
    // This code runs after the game state becomes Playing
    println!("Game is now in Playing state!");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-11"><a class="header" href="#when-to-use-11">When to Use</a></h2>
<p>Use <code>wait::state</code> actions when you need to:</p>
<ul>
<li>Coordinate tasks with Bevy's state system</li>
<li>Wait for specific state transitions before continuing execution</li>
<li>Create game flow sequences that depend on state changes</li>
<li>Implement multi-stage processes that follow a state machine pattern</li>
</ul>
<p>State-based waiting is particularly useful for game flow control, menu navigation, and level transitions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waitaudio"><a class="header" href="#waitaudio">wait::audio</a></h1>
<p>The <code>wait::audio</code> module provides actions for waiting for audio playback to finish. These actions are useful for coordinating tasks with audio playback, allowing tasks to wait for audio to complete before continuing execution.</p>
<h2 id="functions-9"><a class="header" href="#functions-9">Functions</a></h2>
<h3 id="finished"><a class="header" href="#finished">finished</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait::audio::finished() -&gt; ActionSeed&lt;Entity, ()&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that waits until the audio associated with the passed <code>Entity</code> has finished playing. The action completes when the audio playback is complete.</p>
<h4 id="example-20"><a class="header" href="#example-20">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Play a sound effect and get the entity
    let entity = task.will(Update, once::audio::play().with("sounds/explosion.ogg")).await;
    
    // Wait for the sound to finish playing
    task.will(Update, wait::audio::finished().with(entity)).await;
    
    // This code runs after the sound has finished playing
    println!("Sound effect has finished playing!");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-12"><a class="header" href="#when-to-use-12">When to Use</a></h2>
<p>Use <code>wait::audio</code> actions when you need to:</p>
<ul>
<li>Coordinate tasks with audio playback</li>
<li>Create sequences of sounds with precise timing</li>
<li>Ensure an action only occurs after a sound has finished playing</li>
<li>Implement audio-driven gameplay elements</li>
</ul>
<p>Audio waiting is particularly useful for creating polished audio experiences in games, such as ensuring dialog lines don't overlap, creating rhythmic sequences, or synchronizing gameplay events with audio cues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waitinput"><a class="header" href="#waitinput">wait::input</a></h1>
<p>The <code>wait::input</code> module provides actions for waiting for input events. These actions are useful for creating interactive tasks that respond to user input, allowing tasks to wait for specific input events before continuing execution.</p>
<h2 id="functions-10"><a class="header" href="#functions-10">Functions</a></h2>
<h3 id="just_pressed"><a class="header" href="#just_pressed">just_pressed</a></h3>
<pre><code>wait::input::just_pressed&lt;T&gt;() -&gt; ActionSeed&lt;T&gt;
</code></pre>
<p>Creates an action that waits until a button has just been pressed. The action completes when the specified button is pressed.</p>
<h4 id="example-21"><a class="header" href="#example-21">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait until the B key is pressed
    task.will(Update, wait::input::just_pressed().with(KeyCode::KeyB)).await;
    
    // This code runs after the B key is pressed
    println!("B key was pressed!");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pressed"><a class="header" href="#pressed">pressed</a></h3>
<pre><code>wait::input::pressed&lt;T&gt;() -&gt; ActionSeed&lt;T&gt;
</code></pre>
<p>Creates an action that waits until a button is being pressed. The action completes when the specified button is detected as pressed.</p>
<h4 id="example-22"><a class="header" href="#example-22">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait until the B key is being pressed
    task.will(Update, wait::input::pressed().with(KeyCode::KeyB)).await;
    
    // This code runs while the B key is being pressed
    println!("B key is being pressed!");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="any_pressed"><a class="header" href="#any_pressed">any_pressed</a></h3>
<pre><code>wait::input::any_pressed&lt;T&gt;() -&gt; ActionSeed&lt;Vec&lt;T&gt;&gt;
</code></pre>
<p>Creates an action that waits until any button in a list is being pressed. The action completes when any of the specified buttons is detected as pressed.</p>
<h4 id="example-23"><a class="header" href="#example-23">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait until either A or B key is pressed
    task.will(Update, wait::input::any_pressed().with(vec![KeyCode::KeyA, KeyCode::KeyB])).await;
    
    // This code runs when either A or B is pressed
    println!("Either A or B key is being pressed!");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="all_pressed"><a class="header" href="#all_pressed">all_pressed</a></h3>
<pre><code>wait::input::all_pressed&lt;T&gt;() -&gt; ActionSeed&lt;Vec&lt;T&gt;&gt;
</code></pre>
<p>Creates an action that waits until all buttons in a list are being pressed. The action completes when all of the specified buttons are detected as pressed.</p>
<h4 id="example-24"><a class="header" href="#example-24">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait until both A and B keys are pressed
    task.will(Update, wait::input::all_pressed().with(vec![KeyCode::KeyA, KeyCode::KeyB])).await;
    
    // This code runs when both A and B are pressed
    println!("Both A and B keys are being pressed!");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="just_released"><a class="header" href="#just_released">just_released</a></h3>
<pre><code>wait::input::just_released&lt;T&gt;() -&gt; ActionSeed&lt;T&gt;
</code></pre>
<p>Creates an action that waits until a button has just been released. The action completes when the specified button is released.</p>
<h4 id="example-25"><a class="header" href="#example-25">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait until the B key is released
    task.will(Update, wait::input::just_released().with(KeyCode::KeyB)).await;
    
    // This code runs after the B key is released
    println!("B key was released!");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="any_just_released"><a class="header" href="#any_just_released">any_just_released</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait::input::any_just_released&lt;T&gt;() -&gt; ActionSeed&lt;Vec&lt;T&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that waits until any button in a list has just been released. The action completes when any of the specified buttons is released.</p>
<h4 id="example-26"><a class="header" href="#example-26">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait until either A or B key is released
    task.will(Update, wait::input::any_just_released().with(vec![KeyCode::KeyA, KeyCode::KeyB])).await;
    
    // This code runs when either A or B is released
    println!("Either A or B key was released!");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-13"><a class="header" href="#when-to-use-13">When to Use</a></h2>
<p>Use <code>wait::input</code> actions when you need to:</p>
<ul>
<li>Wait for specific user input before continuing execution</li>
<li>Create interactive sequences that respond to player actions</li>
<li>Implement combo systems or special move detection</li>
<li>Create tutorial sequences that guide the player through specific inputs</li>
<li>Build context-sensitive controls that change based on game state</li>
</ul>
<p>Input waiting is particularly useful for creating responsive and interactive gameplay experiences that react to player input in sophisticated ways.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waitall"><a class="header" href="#waitall">wait::all</a></h1>
<p>The <code>wait::all</code> module provides actions for waiting for multiple actions to complete. These actions are useful for coordinating complex tasks that require multiple conditions to be met before continuing execution.</p>
<h2 id="functions-11"><a class="header" href="#functions-11">Functions</a></h2>
<h3 id="all"><a class="header" href="#all">all</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait::all&lt;Actions&gt;() -&gt; ActionSeed&lt;Actions&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that waits until all the specified actions are completed. The output value of this function is <code>()</code>.</p>
<h4 id="example-27"><a class="header" href="#example-27">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use bevy_flurx::actions;
use core::time::Duration;

Reactor::schedule(|task| async move {
    // Wait until all three conditions are met
    task.will(Update, wait::all().with(actions![
        once::run(||{}),
        delay::time().with(Duration::from_millis(300)),
        wait::input::just_pressed().with(KeyCode::KeyA)
    ])).await;
    
    // This code runs after all actions are completed
    println!("All actions completed!");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="wait_all-macro"><a class="header" href="#wait_all-macro">wait_all! (macro)</a></h3>
<pre><code>wait_all![action1, action2, ...]
</code></pre>
<p>A macro that waits until all tasks are done. The return value type is a tuple, with its length equal to the number of passed tasks. This is similar to <code>wait::all()</code>, but it returns the outputs of each action.</p>
<h4 id="example-28"><a class="header" href="#example-28">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use bevy_flurx::wait_all;

#[derive(Default, Clone, Event, PartialEq, Debug)]
struct Event1;
#[derive(Default, Clone, Event, PartialEq, Debug)]
struct Event2;

Reactor::schedule(|task| async move {
    // Wait for both events and get their values
    let (event1, event2) = task.will(Update, wait_all![
        wait::event::read::&lt;Event1&gt;(),
        wait::event::read::&lt;Event2&gt;()
    ]).await;
    
    // This code runs after both events are received
    println!("Received events: {:?}, {:?}", event1, event2);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-14"><a class="header" href="#when-to-use-14">When to Use</a></h2>
<p>Use <code>wait::all</code> and <code>wait_all!</code> when you need to:</p>
<ul>
<li>Wait for multiple conditions to be met before continuing execution</li>
<li>Coordinate complex initialization sequences</li>
<li>Gather results from multiple asynchronous operations</li>
<li>Create synchronization points in your game flow</li>
<li>Implement "AND" logic for multiple waiting conditions</li>
</ul>
<p>For "OR" logic (waiting for any of multiple conditions), consider using <code>wait::any</code> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waitany"><a class="header" href="#waitany">wait::any</a></h1>
<p>The <code>wait::any</code> module provides actions for waiting for any of multiple actions to complete. These actions are useful for creating tasks that can proceed when any of several conditions are met, allowing for more flexible control flow.</p>
<h2 id="functions-12"><a class="header" href="#functions-12">Functions</a></h2>
<h3 id="any"><a class="header" href="#any">any</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait::any&lt;Actions&gt;() -&gt; ActionSeed&lt;Actions, usize&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that waits until the execution of one of the actions is completed. The output value is the index of the completed action.</p>
<h4 id="example-29"><a class="header" href="#example-29">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use bevy_flurx::actions;
use bevy::app::AppExit;

Reactor::schedule(|task| async move {
    // Wait until either the B key is pressed or an AppExit event is received
    let index = task.will(Update, wait::any().with(actions![
        wait::input::just_pressed().with(KeyCode::KeyB),
        wait::event::comes::&lt;AppExit&gt;()
    ])).await;
    
    // Check which action completed
    match index {
        0 =&gt; println!("B key was pressed!"),
        1 =&gt; println!("AppExit event received!"),
        _ =&gt; unreachable!(),
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-15"><a class="header" href="#when-to-use-15">When to Use</a></h2>
<p>Use <code>wait::any</code> when you need to:</p>
<ul>
<li>Wait for the first of several conditions to be met</li>
<li>Create branching logic based on which condition occurs first</li>
<li>Implement timeout patterns with alternative success paths</li>
<li>Handle multiple possible user inputs or events</li>
<li>Implement "OR" logic for multiple waiting conditions</li>
</ul>
<p>For "AND" logic (waiting for all conditions to be met), consider using <code>wait::all</code> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waitboth"><a class="header" href="#waitboth">wait::both</a></h1>
<p>The <code>wait::both</code> module provides an action for waiting for two specific actions to complete. This action is useful for coordinating tasks that require exactly two conditions to be met before continuing execution.</p>
<h2 id="functions-13"><a class="header" href="#functions-13">Functions</a></h2>
<h3 id="both"><a class="header" href="#both">both</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait::both&lt;LI, LO, RI, RO&gt;(lhs: impl Into&lt;Action&lt;LI, LO&gt;&gt; + 'static, rhs: impl Into&lt;Action&lt;RI, RO&gt;&gt; + 'static) -&gt; Action&lt;(LI, RI), (LO, RO)&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that waits until both tasks are done. The output value is a tuple containing the outputs from both actions.</p>
<h4 id="example-30"><a class="header" href="#example-30">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait for both the R key to be pressed and an AppExit event to be received
    let (_, exit_event) = task.will(Update, wait::both(
        wait::input::just_pressed().with(KeyCode::KeyR),
        wait::event::read::&lt;AppExit&gt;()
    )).await;
    
    // This code runs after both conditions are met
    println!("R key was pressed and AppExit event received: {:?}", exit_event);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-16"><a class="header" href="#when-to-use-16">When to Use</a></h2>
<p>Use <code>wait::both</code> when you need to:</p>
<ul>
<li>Wait for exactly two specific conditions to be met</li>
<li>Collect the results from two different asynchronous operations</li>
<li>Coordinate between two different parts of your game</li>
<li>Create synchronization points that depend on two specific events or inputs</li>
<li>Implement simple "AND" logic for exactly two waiting conditions</li>
</ul>
<p>For waiting on more than two conditions, consider using <code>wait::all</code> or the <code>wait_all!</code> macro instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waiteither"><a class="header" href="#waiteither">wait::either</a></h1>
<p>The <code>wait::either</code> module provides an action for waiting for either of two actions to complete. This action is useful for creating tasks that can proceed when either of two conditions is met, allowing for more flexible control flow.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<h3 id="either"><a class="header" href="#either">Either</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;L, R&gt; {
    Left(L),
    Right(R),
}
<span class="boring">}</span></code></pre></pre>
<p>This enum represents the result of <code>wait::either</code>. It contains either the result of the first action (<code>Left</code>) or the result of the second action (<code>Right</code>).</p>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<ul>
<li><code>is_left()</code> - Returns true if the value is <code>Left</code></li>
<li><code>is_right()</code> - Returns true if the value is <code>Right</code></li>
</ul>
<h2 id="functions-14"><a class="header" href="#functions-14">Functions</a></h2>
<h3 id="either-1"><a class="header" href="#either-1">either</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait::either&lt;LI, LO, RI, RO&gt;(lhs: impl Into&lt;Action&lt;LI, LO&gt;&gt; + 'static, rhs: impl Into&lt;Action&lt;RI, RO&gt;&gt; + 'static) -&gt; Action&lt;(LI, RI), Either&lt;LO, RO&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that waits until either of the two tasks is completed. The output value is an <code>Either&lt;LO, RO&gt;</code> enum that indicates which action completed and contains its output.</p>
<h4 id="example-31"><a class="header" href="#example-31">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

Reactor::schedule(|task| async move {
    // Wait until either a system returns false or an AppExit event is received
    let result = task.will(Update, wait::either(
        wait::until(|| false),
        wait::event::read::&lt;AppExit&gt;()
    )).await;
    
    match result {
        Either::Left(_) =&gt; println!("System returned false"),
        Either::Right(exit_event) =&gt; println!("AppExit event received: {:?}", exit_event),
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-17"><a class="header" href="#when-to-use-17">When to Use</a></h2>
<p>Use <code>wait::either</code> when you need to:</p>
<ul>
<li>Wait for the first of two specific conditions to be met</li>
<li>Create branching logic based on which of two conditions occurs first</li>
<li>Implement timeout patterns with a success path</li>
<li>Handle two possible user inputs or events</li>
<li>Implement simple "OR" logic for exactly two waiting conditions</li>
</ul>
<p>For waiting on more than two conditions, consider using <code>wait::any</code> instead. For waiting on both conditions, use <code>wait::both</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delay-1"><a class="header" href="#delay-1">delay</a></h1>
<p>The <code>delay</code> module defines actions that perform delay processing. These are useful for waiting for a specific amount of time or a specific number of frames.</p>
<h2 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h2>
<p>The <code>delay</code> module provides two main functions:</p>
<h3 id="time"><a class="header" href="#time">time</a></h3>
<p>The <code>time</code> function delays the execution for a specified amount of time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Delay for 1 second
        task.will(Update, delay::time().with(Duration::from_secs(1))).await;
        
        // Delay for 500 milliseconds
        task.will(Update, delay::time().with(Duration::from_millis(500))).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<p>Under the hood, <code>delay::time()</code> uses a <code>Timer</code> with <code>TimerMode::Once</code> to track the elapsed time. The action completes when the timer finishes.</p>
<h3 id="frames"><a class="header" href="#frames">frames</a></h3>
<p>The <code>frames</code> function delays the execution for a specified number of frames.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Delay for 30 frames
        task.will(Update, delay::frames().with(30)).await;
        
        // Delay for 5 frames
        task.will(Update, delay::frames().with(5)).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<p>Under the hood, <code>delay::frames()</code> uses a <code>Local&lt;usize&gt;</code> to track the number of frames that have passed. The action completes when the specified number of frames have been processed.</p>
<h2 id="combining-with-other-actions"><a class="header" href="#combining-with-other-actions">Combining with Other Actions</a></h2>
<p>The <code>delay</code> actions can be combined with other actions using the <code>then</code>, <code>pipe</code>, and <code>through</code> methods.</p>
<h3 id="then-1"><a class="header" href="#then-1">then</a></h3>
<p>The <code>then</code> method allows you to execute an action after a delay.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Delay for 1 second, then send an event
        task.will(Update, delay::time().with(Duration::from_secs(1))
            .then(once::event::app_exit_success())
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="through-2"><a class="header" href="#through-2">through</a></h3>
<p>The <code>through</code> method allows you to delay the output of a previous action.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Get a value, then delay for 1 second before returning it
        let value = task.will(Update, once::run(|count: Res&lt;Count&gt;| {
            count.0
        }).through(delay::time().with(Duration::from_secs(1)))).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="delayed-animation"><a class="header" href="#delayed-animation">Delayed Animation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Spawn an entity
        let entity = task.will(Update, once::run(|mut commands: Commands| {
            commands.spawn(SpriteBundle {
                sprite: Sprite {
                    color: Color::RED,
                    custom_size: Some(Vec2::new(50.0, 50.0)),
                    ..default()
                },
                transform: Transform::from_translation(Vec3::new(-100.0, 0.0, 0.0)),
                ..default()
            }).id()
        })).await;
        
        // Move the entity to the right over time
        for i in 0..10 {
            task.will(Update, once::run(move |mut transforms: Query&lt;&amp;mut Transform&gt;| {
                let mut transform = transforms.get_mut(entity).unwrap();
                transform.translation.x += 20.0;
            })).await;
            
            // Delay between movements
            task.will(Update, delay::time().with(Duration::from_millis(100))).await;
        }
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="frame-based-animation"><a class="header" href="#frame-based-animation">Frame-Based Animation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Spawn an entity
        let entity = task.will(Update, once::run(|mut commands: Commands| {
            commands.spawn(SpriteBundle {
                sprite: Sprite {
                    color: Color::BLUE,
                    custom_size: Some(Vec2::new(50.0, 50.0)),
                    ..default()
                },
                transform: Transform::from_translation(Vec3::new(0.0, -100.0, 0.0)),
                ..default()
            }).id()
        })).await;
        
        // Move the entity upward over frames
        for i in 0..10 {
            task.will(Update, once::run(move |mut transforms: Query&lt;&amp;mut Transform&gt;| {
                let mut transform = transforms.get_mut(entity).unwrap();
                transform.translation.y += 20.0;
            })).await;
            
            // Delay between movements
            task.will(Update, delay::frames().with(5)).await;
        }
    }));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-1"><a class="header" href="#sequence-1">sequence</a></h1>
<p>The <code>sequence</code> module provides mechanisms for sequentially combining actions. This is particularly useful for creating complex action flows by chaining multiple actions together.</p>
<h2 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h2>
<p>The <code>sequence</code> module provides two main ways to combine actions:</p>
<ol>
<li>The <code>Then</code> trait: Allows actions to be combined using the <code>then</code> method</li>
<li>The <code>sequence!</code> macro: Provides an alternative syntax for combining actions</li>
</ol>
<h3 id="using-the-then-method"><a class="header" href="#using-the-then-method">Using the <code>then</code> Method</a></h3>
<p>Use the <code>then()</code> method to chain actions together:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Chain actions using the then method
        let result = task.will(Update, 
            once::run(|| {})
                .then(once::run(|| "Hello"))
                .then(once::run(|In(text): In&lt;&amp;str&gt;| format!("{}, World!", text)))
        ).await;

        println!("{}", result); // Prints "Hello, World!"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-the-sequence-macro"><a class="header" href="#using-the-sequence-macro">Using the <code>sequence!</code> Macro</a></h3>
<p>Use the <code>sequence!</code> macro to combine actions with a more declarative syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use bevy_flurx::sequence;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Chain actions using the sequence! macro
        let result = task.will(Update, 
            sequence![
                once::run(|| {}),
                once::run(|| "Hello"),
                once::run(|In(text): In&lt;&amp;str&gt;| format!("{}, World!", text)),
            ]
        ).await;

        println!("{}", result); // Prints "Hello, World!"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>When actions are combined using <code>then</code> or the <code>sequence!</code> macro:</p>
<ol>
<li>The actions are executed in sequence</li>
<li>Each action starts as soon as the previous one completes</li>
<li>If multiple actions complete in the same frame, they will all execute in that frame</li>
<li>The output of the combined action will be that of the last action in the sequence</li>
</ol>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="creating-a-multi-step-process"><a class="header" href="#creating-a-multi-step-process">Creating a Multi-step Process</a></h3>
<p>The <code>sequence</code> module is particularly useful for creating multi-step processes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Create a multi-step process
        task.will(Update, 
            once::run(|| println!("Step 1: Initializing..."))
                .then(once::run(|| println!("Step 2: Processing...")))
                .then(once::run(|| println!("Step 3: Finalizing...")))
                .then(once::run(|| println!("Process completed!")))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="combining-different-types-of-actions"><a class="header" href="#combining-different-types-of-actions">Combining Different Types of Actions</a></h3>
<p>The <code>sequence</code> module can be used to combine different types of actions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Combine different types of actions
        task.will(Update, 
            once::run(|| println!("Waiting for key press..."))
                .then(wait::input::key_pressed(KeyCode::Space))
                .then(once::run(|| println!("Key pressed! Waiting 2 seconds...")))
                .then(delay::seconds(2.0))
                .then(once::run(|| println!("Sequence completed!")))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipe-2"><a class="header" href="#pipe-2">pipe</a></h1>
<p>The <code>pipe</code> module provides a mechanism to pipe actions together, where the output of one action is used as the input for another action. This is particularly useful for creating data processing pipelines.</p>
<h2 id="basic-usage-4"><a class="header" href="#basic-usage-4">Basic Usage</a></h2>
<p>The <code>pipe</code> module provides the <code>Pipe</code> trait, which adds the <code>pipe</code> method to all actions. This method allows you to connect the output of one action to the input of another.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Pipe the output of one action as the input to another
        let result = task.will(Update, 
            once::run(|| "Hello")
                .pipe(once::run(|In(text): In&lt;&amp;str&gt;| format!("{}, World!", text)))
        ).await;

        println!("{}", result); // Prints "Hello, World!"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h2>
<p>When actions are combined using the <code>pipe</code> method:</p>
<ol>
<li>The first action is executed until completion</li>
<li>The output of the first action is passed as input to the second action</li>
<li>The second action is then executed with this input</li>
<li>The output of the combined action will be that of the second action</li>
</ol>
<p>This creates a data flow where information is processed in stages, with each stage building on the results of the previous one.</p>
<h2 id="practical-examples-1"><a class="header" href="#practical-examples-1">Practical Examples</a></h2>
<h3 id="data-processing-pipeline"><a class="header" href="#data-processing-pipeline">Data Processing Pipeline</a></h3>
<p>The <code>pipe</code> module is particularly useful for creating data processing pipelines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Create a data processing pipeline
        let result = task.will(Update, 
            once::run(|| 5) // Generate a number
                .pipe(once::run(|In(num): In&lt;i32&gt;| num * 2)) // Double it
                .pipe(once::run(|In(num): In&lt;i32&gt;| format!("The result is: {}", num))) // Format it
        ).await;

        println!("{}", result); // Prints "The result is: 10"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h3>
<p>The <code>pipe</code> module can be used to process events:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Component)]
struct Hp(u8);

#[derive(Event, Clone)]
struct PlayerHit(Entity);

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Wait for a PlayerHit event and then process it
        task.will(Update, 
            wait::event::read::&lt;PlayerHit&gt;()
                .pipe(once::run(|In(PlayerHit(entity)): In&lt;PlayerHit&gt;, mut players: Query&lt;&amp;mut Hp&gt;| {
                    players.get_mut(entity).unwrap().0 -= 10;
                    println!("Player hit! HP reduced to {}", players.get(entity).unwrap().0);
                }))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="combining-with-other-action-types"><a class="header" href="#combining-with-other-action-types">Combining with Other Action Types</a></h3>
<p>The <code>pipe</code> method can be combined with other action types for more complex behaviors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Combine pipe with other action types
        task.will(Update, 
            wait::input::key_pressed(KeyCode::Space) // Wait for space key
                .pipe(once::run(|_| "Space pressed!")) // Process the event
                .then(delay::seconds(1.0)) // Wait for 1 second
                .then(once::run(|| println!("Ready for next input"))) // Print a message
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="through-3"><a class="header" href="#through-3">through</a></h1>
<p>The <code>through</code> module provides a mechanism to execute an action while preserving the output of the previous action. This is particularly useful for inserting actions like delays into a pipeline without affecting the data flow.</p>
<h2 id="basic-usage-5"><a class="header" href="#basic-usage-5">Basic Usage</a></h2>
<p>The <code>through</code> module provides two main ways to use the functionality:</p>
<ol>
<li>The <code>through</code> function: Creates an action that executes a provided action but preserves the input value as the output</li>
<li>The <code>Through</code> trait: Adds a convenient <code>.through()</code> method to actions, simplifying the chaining of actions</li>
</ol>
<h3 id="using-the-through-function"><a class="header" href="#using-the-through-function">Using the <code>through</code> Function</a></h3>
<p>Use the <code>through()</code> function to create an action that preserves its input:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

#[derive(Event, Clone)]
struct Damage(usize);

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Use through to insert a delay without affecting the data flow
        task.will(Update, wait::event::read::&lt;Damage&gt;()
            .pipe(through(delay::time().with(Duration::from_millis(500))))
            .pipe(once::run(|In(Damage(damage)): In&lt;Damage&gt;| {
                println!("Player takes {damage} points of damage.");
            }))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-the-through-trait"><a class="header" href="#using-the-through-trait">Using the <code>Through</code> Trait</a></h3>
<p>Use the <code>.through()</code> method for a more concise syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

#[derive(Event, Clone)]
struct Damage(usize);

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Use the through method for a more concise syntax
        task.will(Update, wait::event::read::&lt;Damage&gt;()
            .through(delay::time().with(Duration::from_millis(500)))
            .pipe(once::run(|In(Damage(damage)): In&lt;Damage&gt;| {
                println!("Player takes {damage} points of damage.");
            }))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h2>
<p>When using the <code>through</code> function or the <code>Through</code> trait:</p>
<ol>
<li>The original input value is stored</li>
<li>The provided action is executed until completion</li>
<li>The original input value is then forwarded as the output, regardless of the output of the executed action</li>
</ol>
<p>This allows you to insert actions into a pipeline without affecting the data flow, which is particularly useful for actions like delays or logging.</p>
<h2 id="practical-examples-2"><a class="header" href="#practical-examples-2">Practical Examples</a></h2>
<h3 id="adding-delays"><a class="header" href="#adding-delays">Adding Delays</a></h3>
<p>The <code>through</code> module is particularly useful for adding delays without affecting the data flow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Add a delay between steps without affecting the data
        let result = task.will(Update, 
            once::run(|| "Processing...")
                .through(delay::seconds(1.0)) // Wait for 1 second
                .pipe(once::run(|In(text): In&lt;&amp;str&gt;| {
                    format!("{} Completed!", text)
                }))
        ).await;

        println!("{}", result); // Prints "Processing... Completed!"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="logging-without-affecting-data-flow"><a class="header" href="#logging-without-affecting-data-flow">Logging Without Affecting Data Flow</a></h3>
<p>The <code>through</code> module can be used for logging without affecting the data flow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Log data without affecting the pipeline
        let result = task.will(Update, 
            once::run(|| 42)
                .through(once::run(|In(num): In&lt;i32&gt;| {
                    println!("Processing number: {}", num);
                }))
                .pipe(once::run(|In(num): In&lt;i32&gt;| num * 2))
        ).await;

        println!("Result: {}", result); // Prints "Result: 84"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="combining-with-other-action-types-1"><a class="header" href="#combining-with-other-action-types-1">Combining with Other Action Types</a></h3>
<p>The <code>through</code> method can be combined with other action types for more complex behaviors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

#[derive(Event, Clone)]
struct PlayerAction {
    action_type: String,
    value: i32,
}

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Create a complex action flow with through
        task.will(Update, 
            wait::event::read::&lt;PlayerAction&gt;()
                .through(once::run(|In(action): In&lt;PlayerAction&gt;| {
                    println!("Received action: {} with value {}", action.action_type, action.value);
                }))
                .through(delay::time().with(Duration::from_millis(500))) // Add a delay
                .pipe(once::run(|In(action): In&lt;PlayerAction&gt;| {
                    // Process the action
                    action.value * 2
                }))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="omit-1"><a class="header" href="#omit-1">omit</a></h1>
<p>The <code>omit</code> module provides mechanisms to omit input and/or output types from an action. This is particularly useful for defining groups of actions by simplifying their type signatures.</p>
<h2 id="basic-usage-6"><a class="header" href="#basic-usage-6">Basic Usage</a></h2>
<p>The <code>omit</code> module provides three main traits:</p>
<ol>
<li><code>Omit</code>: Omits both input and output types from an action</li>
<li><code>OmitOutput</code>: Omits only the output type from an action</li>
<li><code>OmitInput</code>: Omits only the input type from an action</li>
</ol>
<h3 id="omitting-both-input-and-output"><a class="header" href="#omitting-both-input-and-output">Omitting Both Input and Output</a></h3>
<p>Use the <code>omit()</code> method to omit both input and output types from an action:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        task.will(Update, action()).await;
    }));
}

fn action() -&gt; ActionSeed {
    once::run(|In(num): In&lt;usize&gt;| num)
        .with(1) // ActionSeed&lt;usize, usize&gt;
        .omit() // ActionSeed&lt;(), ()&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="omitting-only-output"><a class="header" href="#omitting-only-output">Omitting Only Output</a></h3>
<p>Use the <code>omit_output()</code> method to omit only the output type from an action:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Create an action that omits only the output type
        task.will(Update, once::run(|In(num): In&lt;usize&gt;| {
                format!("Number: {}", num)
            })
            .with(42)
            .omit_output()
            .pipe(once::run(|| {
                println!("Action completed!");
            }))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="omitting-only-input"><a class="header" href="#omitting-only-input">Omitting Only Input</a></h3>
<p>Use the <code>omit_input()</code> method to omit only the input type from an action:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Create an action that omits only the input type
        let result: usize = task.will(Update, once::run(|In(num): In&lt;usize&gt;| num)
            .with(5)
            .omit_input()
        ).await;
        
        println!("Result: {}", result); // Prints "Result: 5"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="practical-examples-3"><a class="header" href="#practical-examples-3">Practical Examples</a></h2>
<h3 id="creating-reusable-action-groups"><a class="header" href="#creating-reusable-action-groups">Creating Reusable Action Groups</a></h3>
<p>The <code>omit</code> module is particularly useful for creating reusable action groups with simplified type signatures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Define a reusable action that doesn't expose its internal input/output types
fn print_message() -&gt; ActionSeed {
    once::run(|In(message): In&lt;String&gt;| {
        println!("{}", message);
    })
    .with("Hello, world!".to_string())
    .omit()
}

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Use the reusable action
        task.will(Update, print_message()).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="chaining-actions-with-different-types"><a class="header" href="#chaining-actions-with-different-types">Chaining Actions with Different Types</a></h3>
<p>The <code>omit</code> traits can be used to chain actions with different input/output types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Chain actions with different types
        task.will(Update, once::run(|In(num): In&lt;usize&gt;| num * 2)
            .with(3)
            .omit_output() // Discard the output
            .pipe(once::run(|| "Action completed!"))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-1"><a class="header" href="#map-1">map</a></h1>
<p>The <code>map</code> module provides mechanisms to transform the output of an action using a mapping function. This is particularly useful for data transformation and type conversion between actions.</p>
<h2 id="basic-usage-7"><a class="header" href="#basic-usage-7">Basic Usage</a></h2>
<p>The <code>map</code> module provides the <code>Map</code> trait, which adds two main methods to all actions:</p>
<ol>
<li><code>map</code>: Transforms the output of an action by applying a function to it</li>
<li><code>overwrite</code>: Replaces the output of an action with a specified value</li>
</ol>
<h3 id="using-the-map-method"><a class="header" href="#using-the-map-method">Using the <code>map</code> Method</a></h3>
<p>Use the <code>map()</code> method to transform the output of an action:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Transform the output of an action
        let result = task.will(Update, 
            once::run(|| 5)
                .map(|num| num * 2)
        ).await;

        println!("{}", result); // Prints "10"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-the-overwrite-method"><a class="header" href="#using-the-overwrite-method">Using the <code>overwrite</code> Method</a></h3>
<p>Use the <code>overwrite()</code> method to replace the output of an action with a specified value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Replace the output of an action
        let result = task.will(Update, 
            once::run(|| "Original output")
                .overwrite("Replaced output")
        ).await;

        println!("{}", result); // Prints "Replaced output"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works-3"><a class="header" href="#how-it-works-3">How It Works</a></h2>
<p>When using the <code>map</code> or <code>overwrite</code> methods:</p>
<ol>
<li>The original action is executed until completion</li>
<li>The output of the action is transformed using the provided function (for <code>map</code>) or replaced with the specified value (for <code>overwrite</code>)</li>
<li>The transformed or replaced value becomes the output of the combined action</li>
</ol>
<p>This allows for flexible data transformation and type conversion between actions.</p>
<h2 id="practical-examples-4"><a class="header" href="#practical-examples-4">Practical Examples</a></h2>
<h3 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h3>
<p>The <code>map</code> module is particularly useful for converting between different types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Convert a number to a string
        let result = task.will(Update, 
            once::run(|| 42)
                .map(|num| format!("The answer is: {}", num))
        ).await;

        println!("{}", result); // Prints "The answer is: 42"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="data-transformation-in-pipelines"><a class="header" href="#data-transformation-in-pipelines">Data Transformation in Pipelines</a></h3>
<p>The <code>map</code> module can be combined with <code>pipe</code> to create powerful data transformation pipelines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Create a data transformation pipeline
        let result = task.will(Update, 
            once::run(|| 5)
                .map(|num| num * 2) // Transform to 10
                .pipe(once::run(|In(num): In&lt;i32&gt;| {
                    let squared = num * num;
                    squared
                })) // Transform to 100
                .map(|num| format!("Result: {}", num)) // Transform to string
        ).await;

        println!("{}", result); // Prints "Result: 100"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-logic"><a class="header" href="#conditional-logic">Conditional Logic</a></h3>
<p>The <code>map</code> method can be used to implement conditional logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Implement conditional logic
        let score = task.will(Update, once::run(|| 85)).await;
        
        let grade = task.will(Update, 
            once::run(|| score)
                .map(|score| {
                    if score &gt;= 90 { "A" }
                    else if score &gt;= 80 { "B" }
                    else if score &gt;= 70 { "C" }
                    else if score &gt;= 60 { "D" }
                    else { "F" }
                })
        ).await;

        println!("Score: {}, Grade: {}", score, grade); // Prints "Score: 85, Grade: B"
    }));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspect-1"><a class="header" href="#inspect-1">inspect</a></h1>
<p>The <code>inspect</code> module provides mechanisms to clone and inspect input values via auxiliary actions without disrupting their primary flow. This is particularly useful for debugging, logging, or performing side-effects on input values.</p>
<h2 id="basic-usage-8"><a class="header" href="#basic-usage-8">Basic Usage</a></h2>
<p>The <code>inspect</code> module provides two main ways to inspect input values:</p>
<ol>
<li>The <code>inspect</code> function: Creates an action that clones its input, passing one clone to a provided action for processing while forwarding the original input as output</li>
<li>The <code>Inspect</code> trait: Adds a convenient <code>.inspect()</code> method to actions, simplifying the chaining of actions with auxiliary side-effects</li>
</ol>
<h3 id="using-the-inspect-function"><a class="header" href="#using-the-inspect-function">Using the <code>inspect</code> Function</a></h3>
<p>Use the <code>inspect()</code> function to create an action that processes a clone of the input:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Event, Clone)]
struct Damage(u8);

#[derive(Component)]
struct Hp(u8);

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Use inspect to log damage without affecting the main flow
        task.will(Update, wait::event::read::&lt;Damage&gt;()
            .pipe(inspect(once::run(|In(Damage(damage)): In&lt;Damage&gt;| {
                println!("Players take {damage} points of damage.");
            })))
            .pipe(once::run(|In(Damage(damage)): In&lt;Damage&gt;, mut players: Query&lt;&amp;mut Hp&gt;| {
                for mut player in &amp;mut players {            
                    player.0 -= damage;
                }
            }))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-the-inspect-trait"><a class="header" href="#using-the-inspect-trait">Using the <code>Inspect</code> Trait</a></h3>
<p>Use the <code>.inspect()</code> method to achieve the same result with a more concise syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Event, Clone)]
struct Damage(u8);

#[derive(Component)]
struct Hp(u8);

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Use the inspect method for a more concise syntax
        task.will(Update, wait::event::read::&lt;Damage&gt;()
            .inspect(once::run(|In(Damage(damage)): In&lt;Damage&gt;| {
                println!("Players take {damage} points of damage.");
            }))
            .pipe(once::run(|In(Damage(damage)): In&lt;Damage&gt;, mut players: Query&lt;&amp;mut Hp&gt;| {
                for mut player in &amp;mut players {            
                    player.0 -= damage;
                }
            }))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works-4"><a class="header" href="#how-it-works-4">How It Works</a></h2>
<p>When using the <code>inspect</code> function or the <code>Inspect</code> trait:</p>
<ol>
<li>The input value is cloned</li>
<li>One clone is passed to the auxiliary action for processing</li>
<li>The original input is forwarded as the output without modification</li>
<li>Any side-effects in the auxiliary action (e.g., logging, external calls) are executed</li>
</ol>
<p>This ensures that you can perform auxiliary operations (e.g., logging, metrics) while preserving the original input for further use.</p>
<h2 id="practical-examples-5"><a class="header" href="#practical-examples-5">Practical Examples</a></h2>
<h3 id="debugging"><a class="header" href="#debugging">Debugging</a></h3>
<p>The <code>inspect</code> module is particularly useful for debugging:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Debug the value at each step of a pipeline
        let result = task.will(Update, 
            once::run(|| 5)
                .inspect(once::run(|In(num): In&lt;i32&gt;| {
                    println!("Initial value: {}", num);
                }))
                .map(|num| num * 2)
                .inspect(once::run(|In(num): In&lt;i32&gt;| {
                    println!("After multiplication: {}", num);
                }))
                .pipe(once::run(|In(num): In&lt;i32&gt;| num + 3))
                .inspect(once::run(|In(num): In&lt;i32&gt;| {
                    println!("Final value: {}", num);
                }))
        ).await;

        println!("Result: {}", result); // Prints "Result: 13"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h3>
<p>The <code>inspect</code> module can be used for collecting metrics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Resource, Default)]
struct Metrics {
    damage_dealt: u32,
}

#[derive(Event, Clone)]
struct Damage(u8);

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Collect metrics while processing events
        task.will(Update, wait::event::read::&lt;Damage&gt;()
            .inspect(once::run(|In(Damage(damage)): In&lt;Damage&gt;, mut metrics: ResMut&lt;Metrics&gt;| {
                metrics.damage_dealt += damage as u32;
                println!("Total damage dealt: {}", metrics.damage_dealt);
            }))
            .pipe(once::run(|In(Damage(damage)): In&lt;Damage&gt;, mut players: Query&lt;&amp;mut Hp&gt;| {
                for mut player in &amp;mut players {            
                    player.0 -= damage;
                }
            }))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-side-effects"><a class="header" href="#conditional-side-effects">Conditional Side Effects</a></h3>
<p>The <code>inspect</code> module can be used for conditional side effects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Event, Clone)]
struct PlayerAction {
    action_type: ActionType,
    value: i32,
}

#[derive(Clone, PartialEq)]
enum ActionType {
    Attack,
    Heal,
    Move,
}

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Perform conditional side effects based on input values
        task.will(Update, wait::event::read::&lt;PlayerAction&gt;()
            .inspect(once::run(|In(action): In&lt;PlayerAction&gt;| {
                match action.action_type {
                    ActionType::Attack =&gt; println!("Player attacks for {} damage!", action.value),
                    ActionType::Heal =&gt; println!("Player heals for {} health!", action.value),
                    ActionType::Move =&gt; println!("Player moves {} units!", action.value),
                }
            }))
            .pipe(once::run(|In(action): In&lt;PlayerAction&gt;| {
                // Process the action...
                action.value
            }))
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remake-1"><a class="header" href="#remake-1">remake</a></h1>
<p>The <code>remake</code> module provides a mechanism to create a new action based on an existing action's <code>Runner</code> and <code>Output</code>. This is particularly useful for transforming actions while preserving their input type but changing their output type.</p>
<h2 id="basic-usage-9"><a class="header" href="#basic-usage-9">Basic Usage</a></h2>
<p>The <code>remake</code> module provides the <code>Remake</code> trait, which adds the <code>remake</code> method to all actions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Create a new action with a different output type
        let result = task.will(Update, 
            once::run(|| 5)
                .remake(|runner, original_output, new_output| {
                    // Custom runner that uses the original runner but produces a different output
                    CustomRunner {
                        runner,
                        original_output,
                        new_output,
                    }
                })
        ).await;

        println!("{}", result);
    }));
}

// A custom runner that transforms the output
struct CustomRunner&lt;O1, O2&gt; {
    runner: BoxedRunner,
    original_output: Output&lt;O1&gt;,
    new_output: Output&lt;O2&gt;,
}

impl&lt;O1, O2&gt; Runner for CustomRunner&lt;O1, O2&gt;
where
    O1: 'static,
    O2: 'static,
{
    fn run(&amp;mut self, world: &amp;mut World, token: &amp;mut CancellationHandlers) -&gt; RunnerIs {
        // Run the original runner
        let result = self.runner.run(world, token);
        
        // If the original runner completed, transform its output
        if result == RunnerIs::Completed {
            if let Some(value) = self.original_output.take() {
                // Transform the output (example: convert a number to a string)
                let transformed = format!("Value: {}", value);
                self.new_output.set(transformed);
            }
        }
        
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works-5"><a class="header" href="#how-it-works-5">How It Works</a></h2>
<p>When using the <code>remake</code> method:</p>
<ol>
<li>The original action's <code>Runner</code> and <code>Output</code> are captured</li>
<li>A new <code>Runner</code> is created using the provided function, which receives:
<ul>
<li>The original <code>Runner</code></li>
<li>The original <code>Output</code></li>
<li>A new <code>Output</code> for the transformed action</li>
</ul>
</li>
<li>The new <code>Runner</code> can use the original runner's behavior while producing a different output type</li>
</ol>
<p>This allows for advanced customization of action behavior while maintaining type safety.</p>
<h2 id="practical-examples-6"><a class="header" href="#practical-examples-6">Practical Examples</a></h2>
<h3 id="type-conversion-1"><a class="header" href="#type-conversion-1">Type Conversion</a></h3>
<p>The <code>remake</code> module can be used for complex type conversions that require access to the original runner:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Convert a number action to a string action with custom processing
        let result = task.will(Update, 
            once::run(|| 42)
                .remake(|runner, original_output, new_output| {
                    TypeConverter {
                        runner,
                        original_output,
                        new_output,
                    }
                })
        ).await;

        println!("{}", result); // Prints a string representation of 42
    }));
}

struct TypeConverter&lt;O1, O2&gt; {
    runner: BoxedRunner,
    original_output: Output&lt;O1&gt;,
    new_output: Output&lt;O2&gt;,
}

impl&lt;O1, O2&gt; Runner for TypeConverter&lt;O1, O2&gt;
where
    O1: std::fmt::Display + 'static,
    O2: From&lt;String&gt; + 'static,
{
    fn run(&amp;mut self, world: &amp;mut World, token: &amp;mut CancellationHandlers) -&gt; RunnerIs {
        let result = self.runner.run(world, token);
        
        if result == RunnerIs::Completed {
            if let Some(value) = self.original_output.take() {
                let string_value = format!("{}", value);
                self.new_output.set(O2::from(string_value));
            }
        }
        
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-action-composition"><a class="header" href="#advanced-action-composition">Advanced Action Composition</a></h3>
<p>The <code>remake</code> module can be used to create complex action compositions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Create a composite action that logs its execution time
        let result = task.will(Update, 
            once::run(|| "Processing data...")
                .remake(|runner, original_output, new_output| {
                    TimedRunner {
                        runner,
                        original_output,
                        new_output,
                        start_time: None,
                    }
                })
        ).await;

        println!("{}", result); // Prints the result with timing information
    }));
}

struct TimedRunner&lt;O&gt; {
    runner: BoxedRunner,
    original_output: Output&lt;O&gt;,
    new_output: Output&lt;String&gt;,
    start_time: Option&lt;std::time::Instant&gt;,
}

impl&lt;O&gt; Runner for TimedRunner&lt;O&gt;
where
    O: std::fmt::Display + 'static,
{
    fn run(&amp;mut self, world: &amp;mut World, token: &amp;mut CancellationHandlers) -&gt; RunnerIs {
        if self.start_time.is_none() {
            self.start_time = Some(std::time::Instant::now());
        }
        
        let result = self.runner.run(world, token);
        
        if result == RunnerIs::Completed {
            if let Some(value) = self.original_output.take() {
                let elapsed = self.start_time.unwrap().elapsed();
                let timed_result = format!("Result: {} (took {:?})", value, elapsed);
                self.new_output.set(timed_result);
            }
        }
        
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-18"><a class="header" href="#when-to-use-18">When to Use</a></h2>
<p>Use the <code>remake</code> module when you need to:</p>
<ul>
<li>Transform an action's output type in ways that can't be achieved with <code>map</code></li>
<li>Access and modify the behavior of an action's runner</li>
<li>Create custom runners that build upon existing actions</li>
<li>Implement advanced action composition patterns</li>
</ul>
<p>The <code>remake</code> module is particularly useful for library authors and advanced users who need fine-grained control over action behavior and transformation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="switch"><a class="header" href="#switch">switch</a></h1>
<p>The <code>switch</code> module provides a mechanism for coordinating between Reactors and regular Bevy systems through a binary state (on/off).</p>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="switch-resource"><a class="header" href="#switch-resource">Switch Resource</a></h3>
<p>The <code>Switch&lt;M&gt;</code> resource represents a binary state (on/off) that can be used to coordinate between different parts of your application. The generic type parameter <code>M</code> allows you to define different types of switches for different purposes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a marker type for our switch
struct PlayerAnimation;

// Access the switch in a system
fn check_animation_state(switch: Res&lt;Switch&lt;PlayerAnimation&gt;&gt;) {
    if switch.is_on() {
        println!("Player animation is running!");
    } else {
        println!("Player animation is stopped!");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="condition-systems"><a class="header" href="#condition-systems">Condition Systems</a></h3>
<p>The switch module provides several condition systems that can be used with Bevy's <code>run_if</code> functionality to conditionally run systems based on switch states:</p>
<ul>
<li><code>switch_is_on&lt;M&gt;()</code> - Returns true if the switch is on</li>
<li><code>switch_is_off&lt;M&gt;()</code> - Returns true if the switch is off</li>
<li><code>switch_just_turned_on&lt;M&gt;()</code> - Returns true only the first time the switch is detected as on</li>
<li><code>switch_just_turned_off&lt;M&gt;()</code> - Returns true only the first time the switch is detected as off</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct HeavyTask;

fn main() {
    App::new()
        // This system only runs when the HeavyTask switch is on
        .add_systems(Update, (|mut switch: ResMut&lt;Switch&lt;HeavyTask&gt;&gt;| {
            // Do heavy work...

            // Turn off the switch when done
            switch.off();
        }).run_if(switch_is_on::&lt;HeavyTask&gt;))
        
        // This system only runs when the HeavyTask switch just turned off
        .add_systems(Update, (|| {
            println!("Heavy task just completed!");
        }).run_if(switch_just_turned_off::&lt;HeavyTask&gt;));
}</code></pre></pre>
<h2 id="available-actions"><a class="header" href="#available-actions">Available Actions</a></h2>
<p>The switch module provides actions in both the <code>once</code> and <code>wait</code> modules:</p>
<h3 id="onceswitch-1"><a class="header" href="#onceswitch-1">once::switch</a></h3>
<ul>
<li><a href="actions/once/switch.html#on">once::switch::on</a> - Turn a switch on</li>
<li><a href="actions/once/switch.html#off">once::switch::off</a> - Turn a switch off</li>
</ul>
<h3 id="waitswitch-1"><a class="header" href="#waitswitch-1">wait::switch</a></h3>
<ul>
<li><a href="actions/wait/switch.html#on">wait::switch::on</a> - Wait until a switch is turned on</li>
<li><a href="actions/wait/switch.html#off">wait::switch::off</a> - Wait until a switch is turned off</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="coordinating-between-reactors-and-systems"><a class="header" href="#coordinating-between-reactors-and-systems">Coordinating Between Reactors and Systems</a></h3>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct LoadingTask;

fn main() {
    App::new()
        // This system performs a heavy loading task when the switch is on
        .add_systems(Update, (|mut switch: ResMut&lt;Switch&lt;LoadingTask&gt;&gt;| {
            // Simulate loading...
            println!("Loading assets...");
            
            // Turn off the switch when done
            switch.off();
        }).run_if(switch_is_on::&lt;LoadingTask&gt;))
        
        // Spawn a reactor that coordinates the loading sequence
        .add_systems(Startup, |mut commands: Commands| {
            commands.spawn(Reactor::schedule(|task| async move {
                println!("Starting loading sequence...");
                
                // Turn on the loading switch to start the loading task
                task.will(Update, once::switch::on::&lt;LoadingTask&gt;()).await;
                
                // Wait until the loading task is complete (switch is turned off)
                task.will(Update, wait::switch::off::&lt;LoadingTask&gt;()).await;
                
                println!("Loading sequence complete!");
            }));
        });
}</code></pre></pre>
<h3 id="creating-a-state-machine"><a class="header" href="#creating-a-state-machine">Creating a State Machine</a></h3>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Define switch types for different states
struct Idle;
struct Walking;
struct Running;

fn main() {
    App::new()
        // Idle animation system
        .add_systems(Update, (|mut idle_anim: ResMut&lt;IdleAnimation&gt;| {
            idle_anim.play();
        }).run_if(switch_is_on::&lt;Idle&gt;))
        
        // Walking animation system
        .add_systems(Update, (|mut walk_anim: ResMut&lt;WalkAnimation&gt;| {
            walk_anim.play();
        }).run_if(switch_is_on::&lt;Walking&gt;))
        
        // Running animation system
        .add_systems(Update, (|mut run_anim: ResMut&lt;RunAnimation&gt;| {
            run_anim.play();
        }).run_if(switch_is_on::&lt;Running&gt;))
        
        // State transition system
        .add_systems(Update, |
            keys: Res&lt;Input&lt;KeyCode&gt;&gt;,
            mut commands: Commands,
        | {
            if keys.just_pressed(KeyCode::W) {
                commands.spawn(Reactor::schedule(|task| async move {
                    // Turn off all states
                    task.will(Update, once::switch::off::&lt;Idle&gt;()).await;
                    task.will(Update, once::switch::off::&lt;Running&gt;()).await;
                    
                    // Turn on walking state
                    task.will(Update, once::switch::on::&lt;Walking&gt;()).await;
                }));
            }
            
            if keys.just_pressed(KeyCode::ShiftLeft) {
                commands.spawn(Reactor::schedule(|task| async move {
                    // Turn off all states
                    task.will(Update, once::switch::off::&lt;Idle&gt;()).await;
                    task.will(Update, once::switch::off::&lt;Walking&gt;()).await;
                    
                    // Turn on running state
                    task.will(Update, once::switch::on::&lt;Running&gt;()).await;
                }));
            }
            
            if keys.just_released(KeyCode::W) &amp;&amp; keys.just_released(KeyCode::ShiftLeft) {
                commands.spawn(Reactor::schedule(|task| async move {
                    // Turn off all states
                    task.will(Update, once::switch::off::&lt;Walking&gt;()).await;
                    task.will(Update, once::switch::off::&lt;Running&gt;()).await;
                    
                    // Turn on idle state
                    task.will(Update, once::switch::on::&lt;Idle&gt;()).await;
                }));
            }
        });
}</code></pre></pre>
<h2 id="when-to-use-19"><a class="header" href="#when-to-use-19">When to Use</a></h2>
<p>Use the switch module when you need to:</p>
<ul>
<li>Coordinate between Reactors and regular Bevy systems</li>
<li>Control when certain systems should run</li>
<li>Signal the completion of asynchronous tasks</li>
<li>Create state machines with clear on/off states</li>
<li>Implement gameplay sequences that depend on switch states</li>
</ul>
<p>Switches are particularly useful for tasks that need to be performed on the main thread but need to be coordinated with asynchronous Reactor tasks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="record-actions"><a class="header" href="#record-actions">Record Actions</a></h1>
<p>The <code>record</code> module provides actions for managing operation history with undo and redo capabilities. These actions allow you to track operations, roll them back (undo), and reapply them (redo).</p>
<h2 id="available-record-actions"><a class="header" href="#available-record-actions">Available Record Actions</a></h2>
<ul>
<li><a href="actions/record/push.html">push</a> - Push an operation onto the record history</li>
<li><a href="actions/record/undo.html">undo</a> - Undo operations from the record history</li>
<li><a href="actions/record/redo.html">redo</a> - Redo previously undone operations</li>
<li><a href="actions/record/extension.html">extension</a> - Extensions for using record actions with events and triggers</li>
<li><a href="actions/record/all_clear.html">all_clear</a> - Clear all history of undo and redo operations</li>
</ul>
<h2 id="basic-usage-10"><a class="header" href="#basic-usage-10">Basic Usage</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Define an operation type
struct MoveAct;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Push an operation onto the record history
        task.will(Update, record::push()
            .with(Track {
                act: MoveAct,
                rollback: Rollback::undo_redo(|| once::run(|mut player: Query&lt;&amp;mut Transform&gt;| {
                    let pos = player.single_mut().unwrap().translation;
                    player.single_mut().unwrap().translation = Vec3::Z;
                    RedoAction::new(once::run(move |mut player: Query&lt;&amp;mut Transform&gt;| {
                        player.single_mut().unwrap().translation = pos;
                    }))
                }))
            })
        ).await.expect("Failed to push operation");

        // Undo the operation
        task.will(Update, record::undo::once::&lt;MoveAct&gt;())
            .await.expect("Failed to undo operation");

        // Redo the operation
        task.will(Update, record::redo::once::&lt;MoveAct&gt;())
            .await.expect("Failed to redo operation");
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="track"><a class="header" href="#track">Track</a></h3>
<p>The <code>Track</code> struct represents an operation to be recorded, containing:</p>
<ul>
<li><code>act</code>: The actual operation being recorded</li>
<li><code>rollback</code>: The process called when a rollback is requested</li>
</ul>
<h3 id="rollback"><a class="header" href="#rollback">Rollback</a></h3>
<p>The <code>Rollback</code> struct holds the function called when an undo operation is requested. It can be created in several ways:</p>
<ul>
<li><code>new()</code>: Creates a rollback with a function that may optionally create a redo action</li>
<li><code>undo()</code>: Creates a rollback that doesn't create a redo action</li>
<li><code>undo_redo()</code>: Creates a rollback that always creates a redo action</li>
<li><code>parts()</code>: Declares undo and redo separately with <code>Undo</code> and <code>Redo</code> types</li>
</ul>
<h3 id="redoaction"><a class="header" href="#redoaction">RedoAction</a></h3>
<p>The <code>RedoAction</code> struct represents an action executed when a redo operation is called.</p>
<h2 id="when-to-use-20"><a class="header" href="#when-to-use-20">When to Use</a></h2>
<p>Use record actions when you need to:</p>
<ul>
<li>Implement undo/redo functionality in your application</li>
<li>Track user operations for later reversal</li>
<li>Create a history of operations that can be navigated</li>
</ul>
<p>The record module is particularly useful for applications like editors, games with rewind mechanics, or any application where users might want to undo their actions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recordpush"><a class="header" href="#recordpush">record::push</a></h1>
<p>The <code>record::push</code> function allows you to add operations to the record history for later undo and redo operations.</p>
<h2 id="function-signature"><a class="header" href="#function-signature">Function Signature</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::push&lt;Act&gt;() -&gt; ActionSeed&lt;Track&lt;Act&gt;, EditRecordResult&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that pushes a <code>Track</code> onto the <code>Record</code>. The output will be an <code>EditRecordResult</code>, which will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h2 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h2>
<ul>
<li><code>Act</code>: The type of operation being recorded. This is a generic type parameter that allows you to define different types of operations.</li>
</ul>
<h2 id="return-value-3"><a class="header" href="#return-value-3">Return Value</a></h2>
<p>Returns an <code>ActionSeed&lt;Track&lt;Act&gt;, EditRecordResult&gt;</code> that, when executed, will push the provided <code>Track</code> onto the <code>Record</code>.</p>
<h2 id="example-32"><a class="header" href="#example-32">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

// Define an operation type
struct MoveAct;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Push an operation onto the record history
        task.will(Update, record::push()
            .with(Track {
                act: MoveAct,
                rollback: Rollback::undo_redo(|| once::run(|mut player: Query&lt;&amp;mut Transform&gt;| {
                    let pos = player.single_mut().unwrap().translation;
                    player.single_mut().unwrap().translation = Vec3::Z;
                    RedoAction::new(once::run(move |mut player: Query&lt;&amp;mut Transform&gt;| {
                        player.single_mut().unwrap().translation = pos;
                    }))
                }))
            })
        ).await.expect("An error will be returned if undo or redo is operating.");
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-a-track"><a class="header" href="#creating-a-track">Creating a Track</a></h2>
<p>The <code>Track</code> struct is used to define an operation and its rollback behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Track {
    act: YourActType,
    rollback: Rollback::undo_redo(|| /* your undo action */)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="track-fields"><a class="header" href="#track-fields">Track Fields</a></h3>
<ul>
<li><code>act</code>: The operation being recorded. This can be any type that implements <code>Send + Sync + 'static</code>.</li>
<li><code>rollback</code>: The process called when a rollback is requested. This is created using one of the <code>Rollback</code> methods.</li>
</ul>
<h3 id="rollback-methods"><a class="header" href="#rollback-methods">Rollback Methods</a></h3>
<ul>
<li><code>Rollback::new()</code>: Creates a rollback with a function that may optionally create a redo action.</li>
<li><code>Rollback::undo()</code>: Creates a rollback that doesn't create a redo action.</li>
<li><code>Rollback::undo_redo()</code>: Creates a rollback that always creates a redo action.</li>
<li><code>Rollback::parts()</code>: Declares undo and redo separately with <code>Undo</code> and <code>Redo</code> types.</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The <code>push</code> function returns an <code>EditRecordResult</code>, which is a <code>Result&lt;(), UndoRedoInProgress&gt;</code>. If an undo or redo operation is in progress, the function will return <code>Err(UndoRedoInProgress)</code>.</p>
<h2 id="when-to-use-21"><a class="header" href="#when-to-use-21">When to Use</a></h2>
<p>Use <code>record::push</code> when you need to:</p>
<ul>
<li>Add an operation to the record history</li>
<li>Define how an operation can be undone and redone</li>
<li>Track user actions for later reversal</li>
</ul>
<p>This function is the foundation of the record system, as it allows you to define operations and their rollback behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recordundo"><a class="header" href="#recordundo">record::undo</a></h1>
<p>The <code>record::undo</code> module provides actions for undoing operations that have been pushed onto the record history.</p>
<h2 id="functions-15"><a class="header" href="#functions-15">Functions</a></h2>
<h3 id="once-1"><a class="header" href="#once-1">once</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::undo::once&lt;Act&gt;() -&gt; ActionSeed&lt;(), EditRecordResult&gt;
<span class="boring">}</span></code></pre></pre>
<p>Pops the last pushed undo action, and then executes it. The output will be an <code>EditRecordResult</code>, which will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h4 id="example-33"><a class="header" href="#example-33">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct Act;

Reactor::schedule(|task| async move {
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    }))
        .await
        .expect("An error will be returned if undo or redo is operating.");
    
    task.will(Update, record::undo::once::&lt;Act&gt;())
        .await
        .expect("An error will be returned if undo or redo is operating.");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="index_to"><a class="header" href="#index_to">index_to</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::undo::index_to&lt;Act&gt;() -&gt; ActionSeed&lt;usize, EditRecordResult&gt;
<span class="boring">}</span></code></pre></pre>
<p>Pops undo actions up to the specified index. The output will be an <code>EditRecordResult</code>, which will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h4 id="example-34"><a class="header" href="#example-34">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct Act;

Reactor::schedule(|task| async move {
    // Push multiple operations
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    // Undo operations up to index 1 (keeping the first operation)
    task.will(Update, record::undo::index_to::&lt;Act&gt;().with(1))
        .await
        .expect("An error will be returned if undo or redo is operating.");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="to"><a class="header" href="#to">to</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::undo::to&lt;Act&gt;() -&gt; ActionSeed&lt;Act, EditRecordResult&gt;
<span class="boring">}</span></code></pre></pre>
<p>Pops undo actions until the specified operation is reached. The output will be an <code>EditRecordResult</code>, which will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h4 id="example-35"><a class="header" href="#example-35">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(PartialEq)]
enum Act {
    Move,
    Rotate,
    Scale,
}

Reactor::schedule(|task| async move {
    // Push multiple operations
    task.will(Update, record::push().with(Track {
        act: Act::Move,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act::Rotate,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act::Scale,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    // Undo operations until Act::Move is reached
    task.will(Update, record::undo::to().with(Act::Move))
        .await
        .expect("An error will be returned if undo or redo is operating.");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="all-1"><a class="header" href="#all-1">all</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::undo::all&lt;Act&gt;() -&gt; ActionSeed&lt;(), EditRecordResult&gt;
<span class="boring">}</span></code></pre></pre>
<p>Pops all the undo actions from the <code>Record</code>. The output will be an <code>EditRecordResult</code>, which will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h4 id="example-36"><a class="header" href="#example-36">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct Act;

Reactor::schedule(|task| async move {
    // Push multiple operations
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    // Undo all operations
    task.will(Update, record::undo::all::&lt;Act&gt;())
        .await
        .expect("An error will be returned if undo or redo is operating.");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>All undo functions return an <code>EditRecordResult</code>, which is a <code>Result&lt;(), UndoRedoInProgress&gt;</code>. If an undo or redo operation is already in progress, the function will return <code>Err(UndoRedoInProgress)</code>.</p>
<h2 id="when-to-use-22"><a class="header" href="#when-to-use-22">When to Use</a></h2>
<p>Use <code>record::undo</code> actions when you need to:</p>
<ul>
<li>Undo the last operation</li>
<li>Undo operations up to a specific point</li>
<li>Undo all operations</li>
</ul>
<p>These actions are particularly useful for implementing undo functionality in applications like editors, games with rewind mechanics, or any application where users might want to undo their actions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recordredo"><a class="header" href="#recordredo">record::redo</a></h1>
<p>The <code>record::redo</code> module provides actions for redoing operations that have been previously undone.</p>
<h2 id="functions-16"><a class="header" href="#functions-16">Functions</a></h2>
<h3 id="once-2"><a class="header" href="#once-2">once</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::redo::once&lt;Act&gt;() -&gt; ActionSeed&lt;(), EditRecordResult&gt;
<span class="boring">}</span></code></pre></pre>
<p>Pops the last pushed redo action and executes it. After the redo action is executed, the undo action that created it is pushed into the <code>Record</code> again. If the redo stack in the <code>Record</code> is empty, nothing happens.</p>
<p>The output will be an <code>EditRecordResult</code>, which will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h4 id="example-37"><a class="header" href="#example-37">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct Act;

Reactor::schedule(|task| async move {
    // Push an operation
    task.will(Update, record::push().with(
        Track {
            act: Act,
            rollback: Rollback::undo(|| once::run(||{})),
        }))
        .await
        .expect("An error will be returned if undo or redo is operating.");
    
    // Undo the operation
    task.will(Update, record::undo::once::&lt;Act&gt;())
        .await
        .expect("An error will be returned if undo or redo is operating.");
    
    // Redo the operation
    task.will(Update, record::redo::once::&lt;Act&gt;())
        .await
        .expect("An error will be returned if undo or redo is operating.");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="index_to-1"><a class="header" href="#index_to-1">index_to</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::redo::index_to&lt;Act&gt;() -&gt; ActionSeed&lt;usize, EditRecordResult&gt;
<span class="boring">}</span></code></pre></pre>
<p>Pops and executes the redo actions up to the specified index. If the redo stack in the <code>Record</code> is empty, nothing happens.</p>
<p>The output will be an <code>EditRecordResult</code>, which will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h4 id="example-38"><a class="header" href="#example-38">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct Act;

Reactor::schedule(|task| async move {
    // Push multiple operations
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    // Undo all operations
    task.will(Update, record::undo::all::&lt;Act&gt;())
        .await
        .expect("An error will be returned if undo or redo is operating.");
    
    // Redo operations up to index 1 (redoing the first two operations)
    task.will(Update, record::redo::index_to::&lt;Act&gt;().with(1))
        .await
        .expect("An error will be returned if undo or redo is operating.");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="to-1"><a class="header" href="#to-1">to</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::redo::to&lt;Act&gt;() -&gt; ActionSeed&lt;Act, EditRecordResult&gt;
<span class="boring">}</span></code></pre></pre>
<p>Pops and executes the redo actions until the specified operation is reached. If the redo stack in the <code>Record</code> is empty, nothing happens.</p>
<p>The output will be an <code>EditRecordResult</code>, which will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h4 id="example-39"><a class="header" href="#example-39">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(PartialEq)]
enum Act {
    Move,
    Rotate,
    Scale,
}

Reactor::schedule(|task| async move {
    // Push multiple operations
    task.will(Update, record::push().with(Track {
        act: Act::Move,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act::Rotate,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act::Scale,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    // Undo all operations
    task.will(Update, record::undo::all::&lt;Act&gt;())
        .await
        .expect("An error will be returned if undo or redo is operating.");
    
    // Redo operations until Act::Rotate is reached
    task.will(Update, record::redo::to().with(Act::Rotate))
        .await
        .expect("An error will be returned if undo or redo is operating.");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="all-2"><a class="header" href="#all-2">all</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::redo::all&lt;Act&gt;() -&gt; ActionSeed&lt;(), EditRecordResult&gt;
<span class="boring">}</span></code></pre></pre>
<p>Pops and executes all the redo actions from the <code>Record</code>. If the redo stack in the <code>Record</code> is empty, nothing happens.</p>
<p>The output will be an <code>EditRecordResult</code>, which will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h4 id="example-40"><a class="header" href="#example-40">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct Act;

Reactor::schedule(|task| async move {
    // Push multiple operations
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    task.will(Update, record::push().with(Track {
        act: Act,
        rollback: Rollback::undo(|| once::run(||{}))
    })).await.unwrap();
    
    // Undo all operations
    task.will(Update, record::undo::all::&lt;Act&gt;())
        .await
        .expect("An error will be returned if undo or redo is operating.");
    
    // Redo all operations
    task.will(Update, record::redo::all::&lt;Act&gt;())
        .await
        .expect("An error will be returned if undo or redo is operating.");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>All redo functions return an <code>EditRecordResult</code>, which is a <code>Result&lt;(), UndoRedoInProgress&gt;</code>. If an undo or redo operation is already in progress, the function will return <code>Err(UndoRedoInProgress)</code>.</p>
<h2 id="when-to-use-23"><a class="header" href="#when-to-use-23">When to Use</a></h2>
<p>Use <code>record::redo</code> actions when you need to:</p>
<ul>
<li>Redo the last undone operation</li>
<li>Redo operations up to a specific point</li>
<li>Redo all undone operations</li>
</ul>
<p>These actions are particularly useful for implementing redo functionality in applications like editors, games with rewind mechanics, or any application where users might want to redo their previously undone actions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recordall_clear"><a class="header" href="#recordall_clear">record::all_clear</a></h1>
<p>The <code>record::all_clear</code> function clears all history of undo and redo operations from the <code>Record</code>.</p>
<h2 id="function-signature-1"><a class="header" href="#function-signature-1">Function Signature</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>record::all_clear&lt;M: 'static&gt;() -&gt; ActionSeed&lt;(), Result&lt;(), UndoRedoInProgress&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p>Creates an action that clears all history of undo and redo operations from the <code>Record</code>. The output will be an error (<code>UndoRedoInProgress</code>) if an undo or redo operation is in progress.</p>
<h2 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h2>
<ul>
<li><code>M</code>: The type of operation being recorded. This is a generic type parameter that allows you to define different types of operations.</li>
</ul>
<h2 id="return-value-4"><a class="header" href="#return-value-4">Return Value</a></h2>
<p>Returns an <code>ActionSeed&lt;(), Result&lt;(), UndoRedoInProgress&gt;&gt;</code> that, when executed, will clear all history of undo and redo operations from the <code>Record</code>.</p>
<h2 id="example-41"><a class="header" href="#example-41">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

struct MyOperation;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Push some operations
        task.will(Update, record::push().with(Track {
            act: MyOperation,
            rollback: Rollback::undo(|| once::run(||{}))
        })).await.unwrap();
        
        task.will(Update, record::push().with(Track {
            act: MyOperation,
            rollback: Rollback::undo(|| once::run(||{}))
        })).await.unwrap();
        
        // Clear all history
        task.will(Update, record::all_clear::&lt;MyOperation&gt;())
            .await
            .expect("An error will be returned if undo or redo is operating.");
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<p>The <code>all_clear</code> function returns a <code>Result&lt;(), UndoRedoInProgress&gt;</code>. If an undo or redo operation is in progress, the function will return <code>Err(UndoRedoInProgress)</code>.</p>
<h2 id="when-to-use-24"><a class="header" href="#when-to-use-24">When to Use</a></h2>
<p>Use <code>record::all_clear</code> when you need to:</p>
<ul>
<li>Reset the history of operations</li>
<li>Clear all undo and redo stacks</li>
<li>Start fresh with a new history</li>
</ul>
<p>This function is particularly useful when:</p>
<ul>
<li>Starting a new document or project</li>
<li>After a major operation that makes previous history irrelevant</li>
<li>When you want to free up memory used by a large history</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recordextension"><a class="header" href="#recordextension">record::extension</a></h1>
<p>The <code>record::extension</code> module provides functionality for making undo and redo requests from outside the Reactor using events and triggers.</p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<h3 id="requestundo"><a class="header" href="#requestundo">RequestUndo</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum RequestUndo&lt;Act&gt; {
    Once,
    IndexTo(usize),
    To(Act),
    All,
}
<span class="boring">}</span></code></pre></pre>
<p>Represents a request to undo operations. If an undo or redo is already in progress, the request will be ignored.</p>
<ul>
<li><code>Once</code>: Corresponds to <code>record::undo::once</code></li>
<li><code>IndexTo(usize)</code>: Corresponds to <code>record::undo::index_to</code></li>
<li><code>To(Act)</code>: Corresponds to <code>record::undo::to</code></li>
<li><code>All</code>: Corresponds to <code>record::undo::all</code></li>
</ul>
<h3 id="requestredo"><a class="header" href="#requestredo">RequestRedo</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum RequestRedo&lt;Act&gt; {
    Once,
    IndexTo(usize),
    To(Act),
    All,
}
<span class="boring">}</span></code></pre></pre>
<p>Represents a request to redo operations. If an undo or redo is already in progress, the request will be ignored.</p>
<ul>
<li><code>Once</code>: Corresponds to <code>record::redo::once</code></li>
<li><code>IndexTo(usize)</code>: Corresponds to <code>record::redo::index_to</code></li>
<li><code>To(Act)</code>: Corresponds to <code>record::redo::to</code></li>
<li><code>All</code>: Corresponds to <code>record::redo::all</code></li>
</ul>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<h3 id="recordextension-1"><a class="header" href="#recordextension-1">RecordExtension</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait RecordExtension {
    fn add_record&lt;Act&gt;(&amp;mut self) -&gt; &amp;mut Self
    where
        Act: Clone + PartialEq + Send + Sync + 'static;
}
<span class="boring">}</span></code></pre></pre>
<p>Allows undo and redo requests to be made using <code>RequestUndo</code> and <code>RequestRedo</code> from outside the Reactor.</p>
<h4 id="methods-1"><a class="header" href="#methods-1">Methods</a></h4>
<ul>
<li><code>add_record&lt;Act&gt;</code>: Sets up <code>RequestUndo</code> and <code>RequestRedo</code> and their associated systems.</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="using-events"><a class="header" href="#using-events">Using Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

#[derive(Resource, Default)]
struct UndoRedoState {
    can_undo: bool,
    can_redo: bool,
}

fn setup_app(app: &amp;mut App) {
    // Add record functionality for your operation type
    app.add_record::&lt;MyOperation&gt;();
}

fn update_ui_system(
    mut ui_state: ResMut&lt;UndoRedoState&gt;,
    record: Res&lt;Record&lt;MyOperation&gt;&gt;,
) {
    ui_state.can_undo = !record.tracks.is_empty();
    ui_state.can_redo = !record.redo.is_empty();
}

fn handle_input(
    keys: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut undo_events: EventWriter&lt;RequestUndo&lt;MyOperation&gt;&gt;,
    mut redo_events: EventWriter&lt;RequestRedo&lt;MyOperation&gt;&gt;,
) {
    // Handle Ctrl+Z for undo
    if keys.pressed(KeyCode::ControlLeft) &amp;&amp; keys.just_pressed(KeyCode::Z) {
        undo_events.send(RequestUndo::Once);
    }
    
    // Handle Ctrl+Y for redo
    if keys.pressed(KeyCode::ControlLeft) &amp;&amp; keys.just_pressed(KeyCode::Y) {
        redo_events.send(RequestRedo::Once);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-triggers"><a class="header" href="#using-triggers">Using Triggers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn handle_button_click(
    interaction_query: Query&lt;&amp;Interaction, (Changed&lt;Interaction&gt;, With&lt;UndoButton&gt;)&gt;,
    world: &amp;mut World,
) {
    for interaction in interaction_query.iter() {
        if *interaction == Interaction::Clicked {
            // Trigger an undo operation
            world.trigger(RequestUndo::&lt;MyOperation&gt;::Once);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works-6"><a class="header" href="#how-it-works-6">How It Works</a></h2>
<p>When you call <code>app.add_record::&lt;Act&gt;()</code>, the following happens:</p>
<ol>
<li>The <code>Record&lt;Act&gt;</code> resource is initialized</li>
<li>Event types for <code>RequestUndo&lt;Act&gt;</code> and <code>RequestRedo&lt;Act&gt;</code> are registered</li>
<li>Systems are added to handle these events and triggers</li>
</ol>
<p>When a <code>RequestUndo</code> or <code>RequestRedo</code> event is sent or triggered:</p>
<ol>
<li>The corresponding system creates a new Reactor</li>
<li>The Reactor executes the appropriate undo or redo action</li>
<li>If the action fails (e.g., because an undo or redo is already in progress), the error is ignored</li>
</ol>
<h2 id="when-to-use-25"><a class="header" href="#when-to-use-25">When to Use</a></h2>
<p>Use the extension module when you need to:</p>
<ul>
<li>Trigger undo/redo operations from UI elements</li>
<li>Handle keyboard shortcuts for undo/redo</li>
<li>Integrate undo/redo functionality with other systems in your application</li>
</ul>
<p>This module is particularly useful for applications with complex UI that need to provide undo/redo functionality through various means (buttons, keyboard shortcuts, etc.).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="side-effect-actions"><a class="header" href="#side-effect-actions">Side Effect Actions</a></h1>
<p>The <code>side_effect</code> module provides actions for handling operations with side effects such as asynchronous runtime or threads. These actions allow you to execute code outside the main Bevy ECS system while maintaining the Action-based flow.</p>
<h2 id="available-side-effect-actions"><a class="header" href="#available-side-effect-actions">Available Side Effect Actions</a></h2>
<ul>
<li><a href="actions/side_effect/bevy_task.html">bevy_task</a> - Spawn tasks using Bevy's task system</li>
<li><a href="actions/side_effect/thread.html">thread</a> - Spawn OS threads</li>
<li><a href="actions/side_effect/tokio.html">tokio</a> - Spawn tasks using Tokio's runtime</li>
</ul>
<h2 id="basic-usage-11"><a class="header" href="#basic-usage-11">Basic Usage</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Execute a CPU-intensive operation on a separate thread
        let result = task.will(Update, 
            once::run(|| 2)
                .pipe(side_effect::thread::spawn(|num| {
                    // This runs on a separate thread
                    num * 10
                }))
        ).await;
        
        println!("Result: {}", result); // Prints "Result: 20"
        
        // Execute an asynchronous operation using Tokio
        task.will(Update, 
            side_effect::tokio::spawn(async move {
                // This runs on Tokio's runtime
                tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                "Operation completed"
            })
        ).await;
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="core-concepts-2"><a class="header" href="#core-concepts-2">Core Concepts</a></h2>
<h3 id="asyncfunctor"><a class="header" href="#asyncfunctor">AsyncFunctor</a></h3>
<p>The <code>AsyncFunctor</code> trait is implemented for functions that return futures. It allows you to:</p>
<ul>
<li>Pass a function that takes input and returns a future: <code>spawn(|input| async move { ... })</code></li>
<li>Pass a future directly: <code>spawn(async move { ... })</code></li>
</ul>
<h3 id="functor"><a class="header" href="#functor">Functor</a></h3>
<p>The <code>Functor</code> trait is used for functions that need to be executed with side effects. It allows you to:</p>
<ul>
<li>Pass a function that takes input: <code>spawn(|input| { ... })</code></li>
<li>Pass a function without input: <code>spawn(|| { ... })</code></li>
</ul>
<h2 id="when-to-use-26"><a class="header" href="#when-to-use-26">When to Use</a></h2>
<p>Use side_effect actions when you need to:</p>
<ul>
<li>Execute CPU-intensive operations without blocking the main thread</li>
<li>Perform asynchronous operations like network requests or file I/O</li>
<li>Integrate with external asynchronous APIs</li>
<li>Execute code that would otherwise block or slow down the main Bevy ECS system</li>
</ul>
<p>The side_effect module is particularly useful for applications that need to perform operations outside the main game loop, such as loading assets, making network requests, or performing complex calculations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="side_effectbevy_task"><a class="header" href="#side_effectbevy_task">side_effect::bevy_task</a></h1>
<p>The <code>side_effect::bevy_task</code> module provides actions for spawning tasks using Bevy's task system. These actions allow you to execute asynchronous code while maintaining the Action-based flow.</p>
<h2 id="functions-17"><a class="header" href="#functions-17">Functions</a></h2>
<h3 id="spawn"><a class="header" href="#spawn">spawn</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>side_effect::bevy_task::spawn&lt;I, Out, Functor, M&gt;(f: Functor) -&gt; ActionSeed&lt;I, Out&gt;
<span class="boring">}</span></code></pre></pre>
<p>Spawns a future onto the Bevy thread pool and waits until it's completed. The task is started when the Runner is executed for the first time.</p>
<h4 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h4>
<ul>
<li><code>f</code>: A function that returns a future, or a future itself. This can be either:
<ul>
<li>A function that takes input and returns a future: <code>|input| async move { ... }</code></li>
<li>A future directly: <code>async move { ... }</code></li>
</ul>
</li>
</ul>
<h4 id="return-value-5"><a class="header" href="#return-value-5">Return Value</a></h4>
<p>Returns an <code>ActionSeed&lt;I, Out&gt;</code> that, when executed, will spawn the future onto the Bevy thread pool and wait for it to complete.</p>
<h4 id="example-42"><a class="header" href="#example-42">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Spawn a future directly
        task.will(Update, side_effect::bevy_task::spawn(async move {
            // This runs on the Bevy thread pool
            "Hello from Bevy task!"
        })).await;
        
        // Spawn a function that takes input and returns a future
        let result = task.will(Update, 
            once::run(|| 5)
                .pipe(side_effect::bevy_task::spawn(|num| async move {
                    // This runs on the Bevy thread pool
                    num * 2
                }))
        ).await;
        
        println!("Result: {}", result); // Prints "Result: 10"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="spawn_detached"><a class="header" href="#spawn_detached">spawn_detached</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>side_effect::bevy_task::spawn_detached&lt;I, Out, Functor, M&gt;(functor: Functor) -&gt; ActionSeed&lt;I, Out&gt;
<span class="boring">}</span></code></pre></pre>
<p>Spawns a future onto the Bevy thread pool and waits until it's completed. Unlike <code>spawn</code>, the spawned task is detached and continues to run in the background, even if the Reactor is canceled.</p>
<h4 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h4>
<ul>
<li><code>functor</code>: A function that returns a future, or a future itself. This can be either:
<ul>
<li>A function that takes input and returns a future: <code>|input| async move { ... }</code></li>
<li>A future directly: <code>async move { ... }</code></li>
</ul>
</li>
</ul>
<h4 id="return-value-6"><a class="header" href="#return-value-6">Return Value</a></h4>
<p>Returns an <code>ActionSeed&lt;I, Out&gt;</code> that, when executed, will spawn the future onto the Bevy thread pool as a detached task and wait for it to complete.</p>
<h4 id="example-43"><a class="header" href="#example-43">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Spawn a detached future
        task.will(Update, side_effect::bevy_task::spawn_detached(async move {
            // This runs on the Bevy thread pool and continues even if the Reactor is canceled
            "Hello from detached Bevy task!"
        })).await;
        
        // Spawn a function that takes input and returns a future
        let result = task.will(Update, 
            once::run(|| 5)
                .pipe(side_effect::bevy_task::spawn_detached(|num| async move {
                    // This runs on the Bevy thread pool and continues even if the Reactor is canceled
                    num * 2
                }))
        ).await;
        
        println!("Result: {}", result); // Prints "Result: 10"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-27"><a class="header" href="#when-to-use-27">When to Use</a></h2>
<p>Use <code>side_effect::bevy_task</code> actions when you need to:</p>
<ul>
<li>Execute asynchronous code that would block the main thread</li>
<li>Perform operations that can benefit from Bevy's task system</li>
<li>Execute code that should continue even if the Reactor is canceled (using <code>spawn_detached</code>)</li>
</ul>
<p>The <code>bevy_task</code> module is particularly useful for operations that need to be executed asynchronously but don't require the full power of Tokio's runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="side_effectthread"><a class="header" href="#side_effectthread">side_effect::thread</a></h1>
<p>The <code>side_effect::thread</code> module provides actions for spawning OS threads. These actions allow you to execute CPU-intensive code without blocking the main thread while maintaining the Action-based flow.</p>
<h2 id="functions-18"><a class="header" href="#functions-18">Functions</a></h2>
<h3 id="spawn-1"><a class="header" href="#spawn-1">spawn</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>side_effect::thread::spawn&lt;I, O, M&gt;(f: impl Functor&lt;I, O, M&gt; + Send + Sync + 'static) -&gt; ActionSeed&lt;I, O&gt;
<span class="boring">}</span></code></pre></pre>
<p>Spawns a new OS thread and waits for its output. The thread is started when the Runner is executed for the first time. Note that the thread created from this function will continue to run even if the Reactor is canceled.</p>
<h4 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h4>
<ul>
<li><code>f</code>: A function to be executed on a separate thread. This can be either:
<ul>
<li>A function that takes input: <code>|input| { ... }</code></li>
<li>A function without input: <code>|| { ... }</code></li>
</ul>
</li>
</ul>
<h4 id="return-value-7"><a class="header" href="#return-value-7">Return Value</a></h4>
<p>Returns an <code>ActionSeed&lt;I, O&gt;</code> that, when executed, will spawn a new OS thread to execute the function and wait for it to complete.</p>
<h4 id="example-44"><a class="header" href="#example-44">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Execute a function with input on a separate thread
        let result = task.will(Update, 
            once::run(|| 5)
                .pipe(side_effect::thread::spawn(|num| {
                    // This runs on a separate OS thread
                    num * 2
                }))
        ).await;
        
        println!("Result: {}", result); // Prints "Result: 10"
        
        // Execute a function without input on a separate thread
        let result = task.will(Update, 
            side_effect::thread::spawn(|| {
                // This runs on a separate OS thread
                "Hello from thread!"
            })
        ).await;
        
        println!("Result: {}", result); // Prints "Result: Hello from thread!"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-28"><a class="header" href="#when-to-use-28">When to Use</a></h2>
<p>Use <code>side_effect::thread</code> actions when you need to:</p>
<ul>
<li>Execute CPU-intensive operations without blocking the main thread</li>
<li>Perform operations that would otherwise slow down the main game loop</li>
<li>Execute code that should continue even if the Reactor is canceled</li>
</ul>
<p>The <code>thread</code> module is particularly useful for operations that are CPU-bound rather than I/O-bound. For I/O-bound operations, consider using the <code>tokio</code> module instead.</p>
<h2 id="feature-requirements"><a class="header" href="#feature-requirements">Feature Requirements</a></h2>
<p>The <code>thread</code> module requires both the <code>side-effect</code> and <code>std</code> feature flags to be enabled. It is not available on WebAssembly targets.</p>
<pre><code class="language-toml">[dependencies]
bevy_flurx = { version = "0.1", features = ["side-effect", "std"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="side_effecttokio"><a class="header" href="#side_effecttokio">side_effect::tokio</a></h1>
<p>The <code>side_effect::tokio</code> module provides actions for spawning tasks using Tokio's runtime. These actions allow you to execute asynchronous code with Tokio while maintaining the Action-based flow.</p>
<h2 id="functions-19"><a class="header" href="#functions-19">Functions</a></h2>
<h3 id="spawn-2"><a class="header" href="#spawn-2">spawn</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>side_effect::tokio::spawn&lt;I, Out, Functor, M&gt;(f: Functor) -&gt; ActionSeed&lt;I, Out&gt;
<span class="boring">}</span></code></pre></pre>
<p>Spawns a new Tokio task and waits for its output. The task is started when the Runner is executed for the first time.</p>
<h4 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h4>
<ul>
<li><code>f</code>: A function that returns a future, or a future itself. This can be either:
<ul>
<li>A function that takes input and returns a future: <code>|input| async move { ... }</code></li>
<li>A future directly: <code>async move { ... }</code></li>
</ul>
</li>
</ul>
<h4 id="return-value-8"><a class="header" href="#return-value-8">Return Value</a></h4>
<p>Returns an <code>ActionSeed&lt;I, Out&gt;</code> that, when executed, will spawn a new Tokio task to execute the future and wait for it to complete.</p>
<h4 id="example-45"><a class="header" href="#example-45">Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_flurx::prelude::*;

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Execute an asynchronous operation using Tokio
        let result = task.will(Update, 
            side_effect::tokio::spawn(async move {
                // This runs on Tokio's runtime
                tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                "Operation completed"
            })
        ).await;
        
        println!("Result: {}", result); // Prints "Result: Operation completed"
        
        // Execute a function that takes input and returns a future
        let result = task.will(Update, 
            once::run(|| 5)
                .pipe(side_effect::tokio::spawn(|num| async move {
                    // This runs on Tokio's runtime
                    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
                    num * 2
                }))
        ).await;
        
        println!("Result: {}", result); // Prints "Result: 10"
    }));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cancellation-behavior"><a class="header" href="#cancellation-behavior">Cancellation Behavior</a></h2>
<p>Unlike <code>bevy_task::spawn_detached</code> and <code>thread::spawn</code>, Tokio tasks spawned with <code>tokio::spawn</code> are aborted when the Runner is dropped. This means that if the Reactor is canceled, the Tokio task will also be canceled.</p>
<h2 id="when-to-use-29"><a class="header" href="#when-to-use-29">When to Use</a></h2>
<p>Use <code>side_effect::tokio</code> actions when you need to:</p>
<ul>
<li>Perform I/O-bound operations like network requests or file operations</li>
<li>Execute asynchronous code that benefits from Tokio's runtime features</li>
<li>Integrate with other libraries that use Tokio</li>
</ul>
<p>The <code>tokio</code> module is particularly useful for operations that are I/O-bound rather than CPU-bound. For CPU-bound operations, consider using the <code>thread</code> module instead.</p>
<h2 id="feature-requirements-1"><a class="header" href="#feature-requirements-1">Feature Requirements</a></h2>
<p>The <code>tokio</code> module requires the <code>tokio</code> feature flag to be enabled.</p>
<pre><code class="language-toml">[dependencies]
bevy_flurx = { version = "0.1", features = ["tokio"] }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
