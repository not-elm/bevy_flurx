# bevy_flurx Overview

> **Note:**
> This document is generated by AI. If you find any mistakes or unnatural parts, please report them in the issue.

bevy_flurx is a library that provides functionality similar to coroutines for the Bevy game engine, allowing you to write sequential processing for delays, user input, animations, and more.

## What is bevy_flurx?

bevy_flurx allows you to write asynchronous code in a sequential manner, making it easier to implement complex behaviors that involve waiting for events, delays, or other conditions. The library is designed to be used incrementally, meaning there's no need to rewrite existing applications to incorporate it.

The main component of bevy_flurx is the `Reactor`, which schedules and executes tasks. Each task can use various actions to perform operations or wait for conditions.

## Key Features

- **Sequential Processing**: Write code that looks sequential but executes asynchronously
- **Incremental Adoption**: Use alongside existing Bevy systems without rewriting your application
- **Rich Action Library**: Various actions for different use cases:
  - `once`: Actions that run only once
  - `wait`: Actions that continue to execute every frame according to specified conditions
  - `delay`: Actions that perform delay processing
  - Action chaining with `then`, `pipe`, and `through`

## Basic Example

```rust
use bevy::prelude::*;
use bevy_flurx::prelude::*;
use core::time::Duration;

fn main() {
    App::new()
        .insert_resource(Count(0))
        .add_plugins((
            DefaultPlugins,
            FlurxPlugin,
        ))
        .add_systems(Startup, spawn_reactor)
        .run();
}

#[derive(Resource)]
struct Count(usize);

fn spawn_reactor(mut commands: Commands) {
    commands.spawn(Reactor::schedule(|task| async move {
        // Run a system once
        let current_count: usize = task.will(Update, once::run(|mut count: ResMut<Count>| {
            count.0 += 1;
            count.0
        })).await;
        
        // Wait until a condition is met
        task.will(Update, wait::until(|mut count: ResMut<Count>| {
            count.0 += 1;
            count.0 == 4
        })).await;
        
        // Delay for a specific time
        task.will(Update, delay::time().with(Duration::from_secs(1))).await;
        
        // Chain actions together
        let message = task.will(Update, {
            delay::frames().with(30)
                .then(once::run(|count: Res<Count>| {
                    count.0
                }))
                .pipe(once::run(|In(count): In<usize>| {
                    format!("count is {count}")
                }))
        }).await;
        
        info!("Done!");
    }));
}
```

## Feature Flags

bevy_flurx provides several feature flags to enable additional functionality:

| Flag Name   | Description                                                | Default |
|-------------|------------------------------------------------------------|---------|
| audio       | Audio actions                                              | false   |
| record      | Undo/redo actions and events                               | false   |
| side-effect | Thread/async side effects                                  | false   |
| state       | State actions                                              | false   |
| tokio       | Use tokio's runtime directly in the reactor                | false   |
| std         | Enable features that depend on the standard library        | false   |

## Next Steps

Check out the [Actions](./actions/index.md) section to learn more about the different types of actions available in bevy_flurx.